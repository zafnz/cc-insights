import 'dart:async';
import 'dart:developer' as developer;

import 'package:claude_sdk/claude_sdk.dart' as sdk;
import 'package:flutter/foundation.dart';

import '../services/backend_service.dart';
import '../services/log_service.dart';
import '../services/notification_service.dart';
import '../services/persistence_models.dart';
import '../services/persistence_service.dart';
import '../services/runtime_config.dart';
import '../services/event_handler.dart';
import 'agent.dart';
import 'chat_model.dart';
import 'context_tracker.dart';
import 'conversation.dart';
import 'output_entry.dart';
import 'timing_stats.dart';

/// Diagnostic trace — only prints when [sdk.SdkLogger.debugEnabled] is true.
void _t(String tag, String msg) => sdk.SdkLogger.instance.trace(tag, msg);

/// Permission modes for tool execution.
enum PermissionMode {
  /// Requires permission for most operations.
  defaultMode('Default', 'default'),

  /// Auto-approves file operations within project directory.
  acceptEdits('Accept Edits', 'acceptEdits'),

  /// Planning mode with restricted tool access.
  plan('Plan Only', 'plan'),

  /// Dangerous: approves everything without asking.
  bypass('Bypass All', 'bypassPermissions');

  const PermissionMode(this.label, this.apiName);

  /// Display label for the mode.
  final String label;

  /// API name sent to the backend.
  final String apiName;

  /// Finds a [PermissionMode] by its API name string.
  ///
  /// Falls back to [defaultMode] if no match is found.
  static PermissionMode fromApiName(String apiName) {
    return PermissionMode.values.firstWhere(
      (p) => p.apiName == apiName,
      orElse: () => PermissionMode.defaultMode,
    );
  }
}

/// Immutable data class representing a chat.
///
/// A chat is a user-facing conversation unit that belongs to a worktree.
/// It contains a primary conversation for user interaction and zero or more
/// subagent conversations that are read-only.
///
/// Use [copyWith] to create modified copies of this immutable class.
@immutable
class ChatData {
  /// Unique identifier for this chat.
  final String id;

  /// User-visible name for this chat.
  final String name;

  /// The path to the worktree this chat belongs to.
  ///
  /// This references the parent worktree's root directory.
  /// May be null for testing or standalone chats.
  final String? worktreeRoot;

  /// Whether the chat name was auto-generated from the first message.
  ///
  /// When true, the name should be replaced with an AI-generated title
  /// after the first assistant response.
  final bool isAutoGeneratedName;

  /// When this chat was created.
  /// May be null for testing chats.
  final DateTime? createdAt;

  /// The primary conversation for this chat.
  ///
  /// Users interact with this conversation via the input box. It is always
  /// present and allows user input.
  final ConversationData primaryConversation;

  /// Subagent conversations keyed by conversation ID.
  ///
  /// These are created when the SDK spawns subagents via the Task tool.
  /// Subagent conversations are read-only - users cannot send input to them.
  final Map<String, ConversationData> subagentConversations;

  /// Creates a [ChatData] instance.
  const ChatData({
    required this.id,
    required this.name,
    this.worktreeRoot,
    this.isAutoGeneratedName = false,
    this.createdAt,
    required this.primaryConversation,
    this.subagentConversations = const {},
  });

  /// Creates a new chat with default values.
  ///
  /// Generates a unique ID and creates an empty primary conversation.
  /// If [isAutoGeneratedName] is true, the name may be replaced with an
  /// AI-generated title after the first assistant response.
  factory ChatData.create({
    required String name,
    required String worktreeRoot,
    bool isAutoGeneratedName = false,
  }) {
    final id = 'chat-${DateTime.now().millisecondsSinceEpoch}';
    return ChatData(
      id: id,
      name: name,
      worktreeRoot: worktreeRoot,
      isAutoGeneratedName: isAutoGeneratedName,
      createdAt: DateTime.now(),
      primaryConversation: ConversationData.primary(id: 'conv-primary-$id'),
      subagentConversations: const {},
    );
  }

  /// Returns all conversations in this chat.
  ///
  /// The primary conversation is always first, followed by subagent
  /// conversations in no particular order.
  List<ConversationData> get allConversations => [
    primaryConversation,
    ...subagentConversations.values,
  ];

  /// Creates a copy with the given fields replaced.
  ChatData copyWith({
    String? id,
    String? name,
    String? worktreeRoot,
    bool? isAutoGeneratedName,
    DateTime? createdAt,
    ConversationData? primaryConversation,
    Map<String, ConversationData>? subagentConversations,
  }) {
    return ChatData(
      id: id ?? this.id,
      name: name ?? this.name,
      worktreeRoot: worktreeRoot ?? this.worktreeRoot,
      isAutoGeneratedName: isAutoGeneratedName ?? this.isAutoGeneratedName,
      createdAt: createdAt ?? this.createdAt,
      primaryConversation: primaryConversation ?? this.primaryConversation,
      subagentConversations:
          subagentConversations ?? this.subagentConversations,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ChatData &&
        other.id == id &&
        other.name == name &&
        other.worktreeRoot == worktreeRoot &&
        other.isAutoGeneratedName == isAutoGeneratedName &&
        other.createdAt == createdAt &&
        other.primaryConversation == primaryConversation &&
        mapEquals(other.subagentConversations, subagentConversations);
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      name,
      worktreeRoot,
      isAutoGeneratedName,
      createdAt,
      primaryConversation,
      Object.hashAll(subagentConversations.entries),
    );
  }

  @override
  String toString() {
    return 'ChatData(id: $id, name: $name, worktreeRoot: $worktreeRoot, '
        'isAutoGeneratedName: $isAutoGeneratedName, createdAt: $createdAt, '
        'subagentConversations: ${subagentConversations.length})';
  }
}

/// Mutable state holder for a chat.
///
/// Extends [ChangeNotifier] to notify listeners when state changes.
/// Manages both persistent data ([ChatData]) and runtime ephemeral state
/// like the active SDK session and agents.
///
/// Key responsibilities:
/// - Holding the immutable [ChatData] and providing mutation methods
/// - Managing the SDK session lifecycle
/// - Tracking active agents (runtime-only, not persisted)
/// - Managing conversation selection within this chat
class ChatState extends ChangeNotifier {
  ChatData _data;

  /// The SDK session for this chat.
  ///
  /// Null when no session is active. This is the abstract [AgentSession]
  /// interface which works with both the direct CLI and Codex backends.
  sdk.AgentSession? _session;

  /// Subscription to the session's events stream (for EventHandler).
  StreamSubscription<sdk.InsightsEvent>? _eventSubscription;

  /// Subscription to the session's permission request stream.
  StreamSubscription<sdk.PermissionRequest>? _permissionSubscription;

  /// Queue of pending permission requests.
  ///
  /// Multiple permission requests can arrive concurrently (e.g., when Claude
  /// is working on parallel tasks). This queue ensures all requests are
  /// displayed to the user in order, rather than only showing the most recent.
  final List<sdk.PermissionRequest> _pendingPermissions = [];

  /// Whether Claude is currently working (processing a request).
  ///
  /// True when a session is active and Claude is generating a response.
  /// Set to true when a message is sent, set to false when a result or
  /// error is received.
  bool _isWorking = false;

  /// The time when Claude started working.
  ///
  /// Set when [_isWorking] becomes true, cleared when it becomes false.
  /// Used by the UI to show elapsed time in the working indicator.
  DateTime? _workingStartTime;

  /// Whether the context is currently being compacted.
  ///
  /// True when compaction has started (status: "compacting" received),
  /// false when compaction ends (status: null received).
  bool _isCompacting = false;

  /// Active agents keyed by SDK agent ID.
  ///
  /// Agents are runtime-only and are discarded when the session ends.
  /// Maps SDK agent IDs to [Agent] instances.
  final Map<String, Agent> _activeAgents = {};

  /// The ID of the currently selected conversation.
  ///
  /// Null means the primary conversation is selected.
  String? _selectedConversationId;

  /// The selected model for this chat.
  ChatModel _model = ChatModelCatalog.defaultForBackend(
    RuntimeConfig.instance.defaultBackend,
    RuntimeConfig.instance.defaultModel,
  );

  /// The permission mode for this chat.
  ///
  /// Initialized from [RuntimeConfig.instance.defaultPermissionMode].
  PermissionMode _permissionMode = PermissionMode.fromApiName(
    RuntimeConfig.instance.defaultPermissionMode,
  );

  /// The reasoning effort level for this chat (Codex only).
  ///
  /// Controls how much reasoning the model does before responding.
  /// Only applicable when the backend is Codex. Null means use the default.
  sdk.ReasoningEffort? _reasoningEffort;

  /// Capabilities of the backend this chat is using.
  ///
  /// Set when a session starts. Used to guard mid-session calls so that
  /// unsupported operations (e.g., setReasoningEffort on CLI) are never
  /// sent to the backend.
  sdk.BackendCapabilities _capabilities = const sdk.BackendCapabilities();

  /// The last SDK session ID for this chat, used for session resume.
  ///
  /// Set when a session is created successfully.
  /// Cleared when a session ends or errors out.
  /// Persisted to projects.json for resume across app restarts.
  String? _lastSessionId;

  /// Whether this chat has started at least once.
  ///
  /// Once true, the backend is locked for this chat even if the session ends.
  bool _hasStarted = false;

  /// The project root path for persistence updates.
  ///
  /// Set when the chat is associated with a project via [initPersistence].
  /// Required for updating lastSessionId in projects.json.
  String? _projectRoot;

  /// The worktree path for this chat.
  ///
  /// Comes from ChatData.worktreeRoot but stored separately for persistence.
  String? get _worktreePath => _data.worktreeRoot;

  /// The project ID for persistence.
  ///
  /// Set when the chat is associated with a project via [initPersistence].
  /// When null, persistence is disabled (e.g., in tests).
  String? _projectId;

  /// Timer for debouncing meta saves.
  ///
  /// Prevents excessive file writes when model/permissions change rapidly.
  Timer? _metaSaveTimer;

  /// Context window tracking for this chat.
  final ContextTracker _contextTracker = ContextTracker();

  /// Cumulative usage for this chat across all sessions.
  UsageInfo _cumulativeUsage = const UsageInfo.zero();

  /// Per-model usage breakdown for this chat.
  List<ModelUsageInfo> _modelUsage = [];

  /// Timing statistics for this chat (Claude working time, user response time).
  TimingStats _timingStats = const TimingStats.zero();

  /// Timestamps for when each permission request was received.
  ///
  /// Keyed by the permission request's toolUseId. When a permission is
  /// allowed or denied, the elapsed time is added to [_timingStats].
  final Map<String, DateTime> _permissionRequestTimes = {};

  /// Base usage from previous sessions (for resume support).
  ///
  /// When a chat resumes from a previous session, we need to add the
  /// previous session's final usage to the new session's cumulative values.
  /// This is set by [restoreFromMeta] and cleared when a new session starts
  /// without resuming.
  UsageInfo _baseUsage = const UsageInfo.zero();

  /// Base per-model usage from previous sessions (for resume support).
  List<ModelUsageInfo> _baseModelUsage = [];

  /// Counter for unread messages.
  ///
  /// Incremented when messages arrive while the chat is not being viewed.
  /// Reset to 0 when the chat is selected/viewed.
  int _unreadCount = 0;

  /// Whether this chat is currently being viewed.
  ///
  /// When true, new messages are marked as read immediately.
  /// Set by [markAsViewed] and [markAsNotViewed].
  bool _isBeingViewed = false;

  /// Draft text being typed in the message input.
  ///
  /// Preserved when switching between chats so users don't lose their
  /// in-progress messages.
  String _draftText = '';

  /// The persistence service instance.
  ///
  /// Can be overridden for testing.
  @visibleForTesting
  PersistenceService persistenceService = PersistenceService();

  /// Creates a [ChatState] with the given data.
  ChatState(this._data);

  /// Creates a new [ChatState] with a newly created chat.
  ///
  /// If [isAutoGeneratedName] is true, the name may be replaced with an
  /// AI-generated title after the first assistant response.
  factory ChatState.create({
    required String name,
    required String worktreeRoot,
    bool isAutoGeneratedName = false,
  }) {
    return ChatState(ChatData.create(
      name: name,
      worktreeRoot: worktreeRoot,
      isAutoGeneratedName: isAutoGeneratedName,
    ));
  }

  /// Initializes persistence for this chat.
  ///
  /// Must be called after the chat is associated with a project.
  /// Creates the necessary directories for persistence.
  ///
  /// The [projectId] is used to locate the persistence directory.
  /// The [projectRoot] is the absolute path to the project root, used for
  /// updating lastSessionId in projects.json.
  ///
  /// When persistence is initialized:
  /// - New entries are automatically appended to the JSONL file
  /// - Model/permission changes trigger debounced meta saves
  /// - Session ID changes update projects.json
  Future<void> initPersistence(String projectId, {String? projectRoot}) async {
    _projectId = projectId;
    _projectRoot = projectRoot;
    await persistenceService.ensureDirectories(projectId);
  }

  /// The project ID for persistence, if initialized.
  ///
  /// Returns null if persistence has not been initialized.
  String? get projectId => _projectId;

  /// Context window tracking for this chat.
  ContextTracker get contextTracker => _contextTracker;

  /// Cumulative usage for this chat across all sessions.
  UsageInfo get cumulativeUsage => _cumulativeUsage;

  /// Per-model usage breakdown from the last result message.
  List<ModelUsageInfo> get modelUsage => List.unmodifiable(_modelUsage);

  /// Timing statistics for this chat.
  ///
  /// Tracks how long Claude has spent working and how long the user took
  /// to respond to prompts.
  TimingStats get timingStats => _timingStats;

  /// The immutable chat data.
  ChatData get data => _data;

  /// Whether there is an active SDK session.
  bool get hasActiveSession => _session != null || _testHasActiveSession;

  /// Whether the chat is waiting for a permission response from the user.
  bool get isWaitingForPermission => _pendingPermissions.isNotEmpty;

  /// The currently pending permission request, if any.
  ///
  /// Returns the first request in the queue (FIFO order).
  sdk.PermissionRequest? get pendingPermission =>
      _pendingPermissions.isNotEmpty ? _pendingPermissions.first : null;

  /// The number of pending permission requests in the queue.
  int get pendingPermissionCount => _pendingPermissions.length;

  /// Whether Claude is currently working (processing a request).
  ///
  /// True when a session is active and Claude is generating a response.
  bool get isWorking => _isWorking;

  /// The time when Claude started working, or null if not working.
  ///
  /// Used by the UI to calculate and display elapsed time in the working indicator.
  DateTime? get workingStartTime => _workingStartTime;

  /// Whether the context is currently being compacted.
  ///
  /// When true, the UI should show "Compacting context..." instead of
  /// the regular "Claude is working" indicator.
  bool get isCompacting => _isCompacting;

  /// The currently active agents.
  ///
  /// Returns an unmodifiable view of the active agents map.
  Map<String, Agent> get activeAgents => Map.unmodifiable(_activeAgents);

  /// The currently selected conversation.
  ///
  /// Returns the primary conversation if [_selectedConversationId] is null,
  /// otherwise returns the subagent conversation with that ID.
  ConversationData get selectedConversation {
    if (_selectedConversationId == null) {
      return _data.primaryConversation;
    }
    return _data.subagentConversations[_selectedConversationId] ??
        _data.primaryConversation;
  }

  /// Whether user input is enabled for the current selection.
  ///
  /// Input is only enabled when viewing the primary conversation.
  /// Subagent conversations are read-only.
  bool get isInputEnabled => _selectedConversationId == null;

  /// The selected model for this chat.
  ChatModel get model => _model;

  /// The permission mode for this chat.
  PermissionMode get permissionMode => _permissionMode;

  /// The reasoning effort level for this chat (Codex only).
  ///
  /// Returns null if using the default effort level or if not applicable.
  sdk.ReasoningEffort? get reasoningEffort => _reasoningEffort;

  /// Capabilities of the backend this chat is using.
  ///
  /// Updated when a session starts. Before the first session, returns
  /// an empty capabilities object (all false).
  sdk.BackendCapabilities get capabilities => _capabilities;

  /// The last SDK session ID for this chat, used for session resume.
  ///
  /// Null if no session has been started, or if the last session ended.
  String? get lastSessionId => _lastSessionId;

  /// Whether this chat has started at least once.
  bool get hasStarted => _hasStarted;

  /// Whether the chat name was auto-generated and should be replaced.
  bool get isAutoGeneratedName => _data.isAutoGeneratedName;

  /// Whether this chat has unread messages.
  ///
  /// True when messages have arrived while the chat was not being viewed.
  bool get hasUnreadMessages => _unreadCount > 0;

  /// The number of unread messages in this chat.
  int get unreadCount => _unreadCount;

  /// Draft text being typed in the message input.
  String get draftText => _draftText;
  set draftText(String value) => _draftText = value;

  /// Sets the last session ID for this chat.
  ///
  /// Called by [ProjectRestoreService] when restoring a chat from persistence.
  /// This allows the session ID to be restored without triggering a persistence
  /// save (since it's already persisted).
  void setLastSessionIdFromRestore(String? sessionId) {
    _lastSessionId = sessionId;
  }

  /// Sets the started flag when restoring from persistence.
  ///
  /// Used to lock the backend selector for existing chats.
  void setHasStartedFromRestore(bool hasStarted) {
    if (hasStarted) {
      _hasStarted = true;
    }
  }

  /// Marks this chat as being viewed.
  ///
  /// Resets the unread count to 0 and sets the viewing flag.
  /// Call this when the chat is selected in the UI.
  void markAsViewed() {
    final hadUnread = _unreadCount > 0;
    _unreadCount = 0;
    _isBeingViewed = true;
    if (hadUnread) {
      notifyListeners();
    }
  }

  /// Marks this chat as no longer being viewed.
  ///
  /// Call this when a different chat is selected or the chat panel is closed.
  void markAsNotViewed() {
    _isBeingViewed = false;
  }

  /// Increments the unread message counter.
  ///
  /// Only increments if the chat is not currently being viewed.
  /// Called when new messages arrive from the SDK.
  void _incrementUnread() {
    if (!_isBeingViewed) {
      _unreadCount++;
      notifyListeners();
    }
  }

  /// Sets the model for this chat.
  ///
  /// If a session is active and supports mid-session model changes, this also
  /// updates the model on the running session.
  void setModel(ChatModel model) {
    if (_model != model) {
      _model = model;
      _scheduleMetaSave();
      // Update the model on the active session if one exists
      _session?.setModel(model.id.isEmpty ? null : model.id);
      notifyListeners();
    }
  }

  /// Sets the permission mode for this chat.
  ///
  /// If a session is active and the backend supports mid-session permission
  /// changes, this also updates the permission mode on the running session.
  /// If the backend does not support permission mode changes, the value is
  /// stored locally but not sent to the session.
  void setPermissionMode(PermissionMode mode) {
    if (_permissionMode != mode) {
      _permissionMode = mode;
      _scheduleMetaSave();
      if (_capabilities.supportsPermissionModeChange) {
        _session?.setPermissionMode(_sdkPermissionMode.value);
      }
      notifyListeners();
    }
  }

  /// Sets the reasoning effort level for this chat.
  ///
  /// If a session is active and the backend supports reasoning effort, this
  /// also updates the reasoning effort on the running session. If the backend
  /// does not support reasoning effort, the value is stored locally but not
  /// sent to the session.
  ///
  /// Pass null to use the default effort level.
  void setReasoningEffort(sdk.ReasoningEffort? effort) {
    if (_reasoningEffort != effort) {
      _reasoningEffort = effort;
      _scheduleMetaSave();
      if (_capabilities.supportsReasoningEffort) {
        _session?.setReasoningEffort(effort?.value);
      }
      notifyListeners();
    }
  }

  /// Renames this chat.
  ///
  /// Updates the in-memory state and persists the new name to projects.json.
  /// Also clears the [isAutoGeneratedName] flag since the name is now explicit.
  void rename(String newName) {
    LogService.instance.info('Chat', 'Chat renamed: "${_data.name}" -> "$newName"');
    _data = _data.copyWith(name: newName, isAutoGeneratedName: false);
    notifyListeners();
    _persistRename(newName);
  }

  /// Persists the chat rename to projects.json.
  ///
  /// Does nothing if persistence is not properly initialized.
  void _persistRename(String newName) {
    if (_projectRoot == null || _worktreePath == null) {
      return;
    }
    // Fire and forget - persistence errors are logged but don't block UI
    persistenceService.renameChatInIndex(
      projectRoot: _projectRoot!,
      worktreePath: _worktreePath!,
      chatId: _data.id,
      newName: newName,
    );
  }

  /// Selects a conversation within this chat.
  ///
  /// Pass null to select the primary conversation.
  /// Pass a conversation ID to select a subagent conversation.
  void selectConversation(String? conversationId) {
    if (_selectedConversationId != conversationId) {
      _selectedConversationId = conversationId;
      notifyListeners();
    }
  }

  /// Resets conversation selection to the primary conversation.
  ///
  /// Called when this chat is selected to ensure the user sees
  /// the main conversation first.
  void resetToMainConversation() {
    if (_selectedConversationId != null) {
      _selectedConversationId = null;
      notifyListeners();
    }
  }

  /// Adds a new subagent conversation.
  ///
  /// Creates a new conversation with the given label and task description,
  /// and creates a corresponding [Agent] linked to it.
  ///
  /// The [sdkAgentId] is the SDK's internal agent identifier used to route
  /// messages to the correct agent.
  ///
  /// The [label] is the subagent type (e.g., "general-purpose", "Explore").
  /// The [taskDescription] is a short summary of what the agent will do.
  void addSubagentConversation(
    String sdkAgentId,
    String? label,
    String? taskDescription,
  ) {
    final conversationId = 'conv-${DateTime.now().millisecondsSinceEpoch}';
    // Count existing subagents to generate a fallback label
    final subagentNumber = _data.subagentConversations.length + 1;
    final conversation = ConversationData.subagent(
      id: conversationId,
      label: label,
      taskDescription: taskDescription,
      subagentNumber: subagentNumber,
    );

    _data = _data.copyWith(
      subagentConversations: {
        ..._data.subagentConversations,
        conversationId: conversation,
      },
    );

    _activeAgents[sdkAgentId] = Agent.working(
      sdkAgentId: sdkAgentId,
      conversationId: conversationId,
    );

    notifyListeners();
  }

  /// Updates an agent's status.
  ///
  /// The [sdkAgentId] identifies which agent to update.
  /// The [status] is the new status for the agent.
  /// The optional [result] is set when the agent completes or errors.
  /// The optional [resumeId] is the SDK's short agent ID for resuming.
  void updateAgent(
    AgentStatus status,
    String sdkAgentId, {
    String? result,
    String? resumeId,
  }) {
    final agent = _activeAgents[sdkAgentId];
    if (agent != null) {
      _activeAgents[sdkAgentId] = agent.copyWith(
        status: status,
        result: result,
        resumeId: resumeId ?? agent.resumeId,
      );
      notifyListeners();
    }
  }

  /// Finds an agent by its SDK resume ID.
  ///
  /// The [resumeId] is the short agent ID returned by the SDK (e.g., "adba350")
  /// that can be used with the Task tool's `resume` parameter.
  ///
  /// Returns null if no agent with that resume ID exists.
  Agent? findAgentByResumeId(String resumeId) {
    for (final agent in _activeAgents.values) {
      if (agent.resumeId == resumeId) {
        return agent;
      }
    }
    return null;
  }

  /// Adds an output entry to the primary conversation.
  ///
  /// Convenience method for adding entries to the main conversation.
  void addEntry(OutputEntry entry) {
    addOutputEntry(_data.primaryConversation.id, entry);
  }

  /// Adds an output entry to a conversation.
  ///
  /// The [conversationId] identifies which conversation to add to.
  /// The [entry] is the output entry to append.
  ///
  /// If persistence is initialized, the entry is also appended to the
  /// chat's JSONL file. Only primary conversation entries are persisted.
  void addOutputEntry(String conversationId, OutputEntry entry) {
    if (conversationId == _data.primaryConversation.id) {
      _data = _data.copyWith(
        primaryConversation: _data.primaryConversation.copyWith(
          entries: [..._data.primaryConversation.entries, entry],
        ),
      );
      // Skip persistence for streaming entries - they are persisted
      // when finalized by the assistant message handler.
      final isStreaming =
          (entry is TextOutputEntry && entry.isStreaming) ||
              (entry is ToolUseOutputEntry && entry.isStreaming);
      if (!isStreaming) {
        _persistEntry(entry);
      }
      // Track unread messages for assistant text output
      if (entry is TextOutputEntry && entry.contentType == 'text') {
        _incrementUnread();
      }
    } else {
      final conversation = _data.subagentConversations[conversationId];
      if (conversation != null) {
        _data = _data.copyWith(
          subagentConversations: {
            ..._data.subagentConversations,
            conversationId: conversation.copyWith(
              entries: [...conversation.entries, entry],
            ),
          },
        );
      }
    }
    notifyListeners();
  }

  // ---------------------------------------------------------------------------
  // Session Lifecycle Methods
  // ---------------------------------------------------------------------------

  /// Starts a new SDK session for this chat.
  ///
  /// Creates a session via [BackendService] and subscribes to event and
  /// permission request streams. The [eventHandler] consumes the typed
  /// events stream.
  ///
  /// If [lastSessionId] is set, attempts to resume that session instead of
  /// creating a fresh one. This allows conversations to continue across app
  /// restarts.
  ///
  /// Throws [StateError] if a session is already active.
  /// Throws [StateError] if the chat has no worktree root.
  Future<void> startSession({
    required BackendService backend,
    required EventHandler eventHandler,
    required String prompt,
    List<AttachedImage> images = const [],
  }) async {
    _t('ChatState', '========== startSession ==========');
    _t('ChatState', 'chatId: ${_data.id}');
    _t('ChatState', 'chatName: ${_data.name}');
    _t('ChatState', 'worktreeRoot: ${_data.worktreeRoot}');
    _t('ChatState', 'model: ${model.id} (${model.backend.name})');
    _t('ChatState', 'prompt: ${prompt.length > 80 ? '${prompt.substring(0, 80)}...' : prompt}');
    _t('ChatState', 'images: ${images.length}');
    _t('ChatState', 'lastSessionId: $_lastSessionId');
    _t('ChatState', 'backendReady: ${backend.isReady}');

    if (_session != null) {
      _t('ChatState', 'ERROR: Session already active');
      throw StateError('Session already active');
    }

    final worktreeRoot = _data.worktreeRoot;
    if (worktreeRoot == null) {
      _t('ChatState', 'ERROR: Chat has no worktree root');
      throw StateError('Chat has no worktree root');
    }

    // Log if we're attempting to resume and add a session marker
    final isResumingSession = _lastSessionId != null;
    if (isResumingSession) {
      _t('ChatState', 'Attempting to resume session: $_lastSessionId');
      developer.log(
        'Attempting to resume session: $_lastSessionId',
        name: 'ChatState',
      );
    }

    // Build content blocks if images are attached
    List<sdk.ContentBlock>? content;
    if (images.isNotEmpty) {
      content = <sdk.ContentBlock>[
        if (prompt.trim().isNotEmpty) sdk.TextBlock(text: prompt),
        ...images.map((img) => sdk.ImageBlock(
              source: sdk.ImageSource(
                type: 'base64',
                mediaType: img.mediaType,
                data: img.base64,
              ),
            )),
      ];
    }

    // Create session with current settings, including resume if available
    _t('ChatState', 'Calling backend.createSessionForBackend...');
    final sessionStopwatch = Stopwatch()..start();
    _session = await backend.createSessionForBackend(
      type: model.backend,
      prompt: prompt,
      cwd: worktreeRoot,
      options: sdk.SessionOptions(
        model: model.id.isEmpty ? null : model.id,
        permissionMode: _sdkPermissionMode,
        resume: _lastSessionId,
        // Load permission rules and MCP servers from user, project, and local settings files
        settingSources: const ['user', 'project', 'local'],
        // Use Claude Code's system prompt (includes CLAUDE.md support)
        systemPrompt: const sdk.PresetSystemPrompt(),
        // Stream partial messages if the setting is enabled
        includePartialMessages: RuntimeConfig.instance.streamOfThought,
      ),
      content: content,
    );

    _t('ChatState', 'Session created in ${sessionStopwatch.elapsedMilliseconds}ms');

    // Capture capabilities from the backend so mid-session calls
    // can be guarded without re-querying the backend service.
    _capabilities = backend.capabilitiesFor(model.backend);

    _markStarted();

    // Store the new session ID for future resume.
    // Use resolvedSessionId which returns the SDK's session ID if available.
    final session = _session!;
    final newSessionId = session.resolvedSessionId ?? session.sessionId;
    if (newSessionId != null && newSessionId != _lastSessionId) {
      developer.log(
        'Session created with ID: $newSessionId',
        name: 'ChatState',
      );
      _lastSessionId = newSessionId;
      // Persist the session ID to projects.json (fire-and-forget)
      _persistSessionId(newSessionId);
    }

    // Add a session resumed marker if we successfully resumed
    if (isResumingSession && newSessionId != null) {
      developer.log(
        'Session resumed successfully, adding marker',
        name: 'ChatState',
      );
      addEntry(SessionMarkerEntry(
        timestamp: DateTime.now(),
        markerType: SessionMarkerType.resumed,
      ));
    }

    // Subscribe to events stream for EventHandler
    _eventSubscription = _session!.events.listen(
      (event) {
        eventHandler.handleEvent(this, event);
      },
      onError: (error) {
        // Errors already handled by message stream subscription
        _t('ChatState', 'Event stream ERROR: $error');
      },
    );

    // Subscribe to permission requests
    _t('ChatState', 'Subscribing to permission requests...');
    _permissionSubscription = _session!.permissionRequests.listen(
      (req) {
        _t('ChatState', 'Permission request: tool=${req.toolName} (chat=${_data.id})');
        setPendingPermission(req);
      },
    );

    // Mark as working since we're starting with a prompt
    _isWorking = true;
    _workingStartTime = DateTime.now();

    _t('ChatState', '========== Session fully set up, working=true ==========');
    notifyListeners();
  }

  /// Sends a message to the active session.
  ///
  /// Adds a user input entry to the conversation and sends the message
  /// to the SDK session. Sets the working state to true.
  ///
  /// If [images] is provided and non-empty, the message is sent with
  /// content blocks including the images.
  ///
  /// Throws [StateError] if no session is active.
  Future<void> sendMessage(
    String text, {
    List<AttachedImage> images = const [],
    DisplayFormat displayFormat = DisplayFormat.plain,
  }) async {
    _t('ChatState', 'sendMessage: ${text.length > 80 ? '${text.substring(0, 80)}...' : text} (chat=${_data.id}, images=${images.length})');
    if (_session == null) {
      _t('ChatState', 'ERROR: sendMessage called with no active session');
      throw StateError('No active session');
    }

    // Add user message to conversation
    addEntry(UserInputEntry(
      timestamp: DateTime.now(),
      text: text,
      images: images,
      displayFormat: displayFormat,
    ));

    // Mark as working
    setWorking(true);

    // Send to SDK - use content blocks if images are attached
    if (images.isNotEmpty) {
      final content = <sdk.ContentBlock>[
        if (text.trim().isNotEmpty) sdk.TextBlock(text: text),
        ...images.map((img) => sdk.ImageBlock(
              source: sdk.ImageSource(
                type: 'base64',
                mediaType: img.mediaType,
                data: img.base64,
              ),
            )),
      ];
      await _session!.sendWithContent(content);
    } else {
      await _session!.send(text);
    }
  }

  /// Stops the current session.
  ///
  /// Cancels stream subscriptions, kills the session, and clears
  /// session-related state. Active agents are also cleared.
  Future<void> stopSession() async {
    _t('ChatState', 'stopSession (chat=${_data.id}, hasSession=${_session != null})');
    await _permissionSubscription?.cancel();
    await _eventSubscription?.cancel();
    await _session?.kill();

    _session = null;
    _eventSubscription = null;
    _permissionSubscription = null;
    _pendingPermissions.clear();
    _activeAgents.clear();

    _t('ChatState', 'Session stopped');
    notifyListeners();
  }

  /// Interrupts the current session without killing it.
  ///
  /// This preserves the conversation context and allows Claude to continue
  /// after the interruption. Use this when the user wants to stop the current
  /// response but may want to continue the conversation.
  ///
  /// Does nothing if no session is active.
  Future<void> interrupt() async {
    // Check if we have an active session (either real or test)
    if (!hasActiveSession) return;

    developer.log('Interrupting session', name: 'ChatState');

    // Only call SDK interrupt if we have a real session
    if (_session != null) {
      await _session!.interrupt();
    }

    // Clear the working/compacting state - Claude will stop generating
    _isWorking = false;
    _isCompacting = false;
    _workingStartTime = null;

    // Update all active agents to error state since they were interrupted
    for (final sdkAgentId in _activeAgents.keys.toList()) {
      final agent = _activeAgents[sdkAgentId];
      if (agent != null && agent.status == AgentStatus.working) {
        _activeAgents[sdkAgentId] = agent.copyWith(
          status: AgentStatus.error,
          result: 'Interrupted by user',
        );
      }
    }

    notifyListeners();
  }

  /// Adds a permission request to the queue.
  ///
  /// Permission requests are processed in FIFO order. When multiple requests
  /// arrive concurrently, they are all queued and displayed to the user
  /// one at a time.
  ///
  /// Also sends a desktop notification to alert the user and records the
  /// timestamp for tracking user response time.
  void addPendingPermission(sdk.PermissionRequest request) {
    LogService.instance.notice('Permission', 'Permission requested: tool=${request.toolName}', meta: {'chat': _data.name});
    _pendingPermissions.add(request);

    // Record when this permission request was received for timing tracking
    final toolUseId = request.toolUseId;
    if (toolUseId != null) {
      _permissionRequestTimes[toolUseId] = DateTime.now();
    }

    notifyListeners();

    // Send desktop notification with navigation context
    final worktreeRoot = _data.worktreeRoot;
    if (worktreeRoot != null) {
      NotificationService.instance.notifyPermissionRequest(
        toolName: request.toolName,
        chatName: _data.name,
        worktreeRoot: worktreeRoot,
        chatId: _data.id,
      );
    }
  }

  /// @deprecated Use [addPendingPermission] instead.
  ///
  /// This method is kept for backwards compatibility but ignores null values.
  void setPendingPermission(sdk.PermissionRequest? request) {
    if (request != null) {
      addPendingPermission(request);
    }
  }

  /// Sets the working state.
  ///
  /// Called by [EventHandler] when starting/stopping work.
  /// When [working] is true, records the current time as [_workingStartTime].
  /// When [working] is false, calculates elapsed time and adds it to
  /// [_timingStats], then clears [_workingStartTime].
  void setWorking(bool working) {
    if (_isWorking != working) {
      // When transitioning from working to not working, record the elapsed time
      if (!working && _workingStartTime != null) {
        final elapsed = DateTime.now().difference(_workingStartTime!);
        _timingStats = _timingStats.addClaudeWorkingTime(elapsed);
        _scheduleMetaSave();
      }

      _isWorking = working;
      _workingStartTime = working ? DateTime.now() : null;
      notifyListeners();
    }
  }

  /// Sets the compacting state.
  ///
  /// Called by [EventHandler] when receiving system status messages
  /// for context compaction. The UI can use [isCompacting] to show a
  /// different indicator during compaction.
  void setCompacting(bool compacting) {
    if (_isCompacting != compacting) {
      _isCompacting = compacting;
      notifyListeners();
    }
  }

  /// Responds to the current pending permission request with allow.
  ///
  /// If [updatedInput] is provided, it will be sent with the allow response.
  /// If [updatedPermissions] is provided, it will update the permission rules.
  ///
  /// After allowing, the next request in the queue (if any) becomes current.
  /// The user response time is recorded in [_timingStats].
  void allowPermission({
    Map<String, dynamic>? updatedInput,
    List<dynamic>? updatedPermissions,
  }) {
    if (_pendingPermissions.isEmpty) return;

    final request = _pendingPermissions.removeAt(0);

    // Track user response time
    _recordPermissionResponseTime(request.toolUseId);

    // Sync local permission mode when the response includes a setMode directive
    // or when ExitPlanMode is approved (implicitly exits plan mode to default).
    _syncPermissionModeFromResponse(request.toolName, updatedPermissions);

    LogService.instance.info('Permission', 'Permission allowed: tool=${request.toolName}', meta: {'chat': _data.name});
    request.allow(
      updatedInput: updatedInput,
      updatedPermissions: updatedPermissions,
    );
    notifyListeners();
  }

  /// Syncs the local [_permissionMode] based on a permission response.
  ///
  /// Checks [updatedPermissions] for a `setMode` directive and updates
  /// accordingly. If the approved tool is `ExitPlanMode` with no explicit
  /// mode change, reverts to [PermissionMode.defaultMode] since plan mode
  /// has ended.
  void _syncPermissionModeFromResponse(
    String? toolName,
    List<dynamic>? updatedPermissions,
  ) {
    // Check for explicit setMode in updatedPermissions
    if (updatedPermissions != null) {
      for (final perm in updatedPermissions) {
        if (perm is Map<String, dynamic> && perm['type'] == 'setMode') {
          final mode = perm['mode'] as String?;
          if (mode != null) {
            _permissionMode = PermissionMode.fromApiName(mode);
            _scheduleMetaSave();
            return;
          }
        }
      }
    }

    // ExitPlanMode approved without explicit setMode → revert to default
    if (toolName == 'ExitPlanMode') {
      _permissionMode = PermissionMode.defaultMode;
      _scheduleMetaSave();
    }
  }

  /// Responds to the current pending permission request with deny.
  ///
  /// The [message] explains why the permission was denied.
  /// If [interrupt] is true, the session will be interrupted.
  ///
  /// After denying, the next request in the queue (if any) becomes current.
  /// The user response time is recorded in [_timingStats].
  void denyPermission(String message, {bool interrupt = false}) {
    if (_pendingPermissions.isEmpty) return;

    final request = _pendingPermissions.removeAt(0);

    // Track user response time
    _recordPermissionResponseTime(request.toolUseId);

    LogService.instance.info('Permission', 'Permission denied: tool=${request.toolName}', meta: {'chat': _data.name});
    request.deny(message, interrupt: interrupt);
    notifyListeners();
  }

  /// Removes a pending permission request by tool use ID.
  ///
  /// This handles the timeout case: when the SDK times out waiting for
  /// permission, it sends a tool result (denied), and we should dismiss
  /// the stale permission widget.
  ///
  /// This is safe for parallel tool calls because we match by toolUseId,
  /// so only the specific tool's permission is cleared, not others.
  ///
  /// Note: This does NOT record user response time since the permission
  /// was timed out, not responded to by the user.
  void removePendingPermissionByToolUseId(String toolUseId) {
    final before = _pendingPermissions.length;
    _pendingPermissions.removeWhere((req) => req.toolUseId == toolUseId);

    // Clean up the timing map (no response time recorded for timeouts)
    _permissionRequestTimes.remove(toolUseId);

    if (_pendingPermissions.length != before) {
      notifyListeners();
    }
  }

  /// Records the user response time for a permission request.
  ///
  /// Looks up when the permission request was received and calculates
  /// the elapsed time. Adds it to [_timingStats] and removes the entry
  /// from [_permissionRequestTimes].
  void _recordPermissionResponseTime(String? toolUseId) {
    if (toolUseId == null) return;
    final startTime = _permissionRequestTimes.remove(toolUseId);
    if (startTime != null) {
      final elapsed = DateTime.now().difference(startTime);
      _timingStats = _timingStats.addUserResponseTime(elapsed);
      _scheduleMetaSave();
    }
  }

  /// Handles errors from the session message stream.
  void _handleError(Object error) {
    _t('ChatState', '_handleError: $error (chat=${_data.id})');
    developer.log(
      'Session error: $error',
      name: 'ChatState',
      error: error,
    );

    // Add error entry to conversation
    addEntry(TextOutputEntry(
      timestamp: DateTime.now(),
      text: 'Error: $error',
      contentType: 'error',
    ));

    // Clear session ID on error - the session may be in an invalid state
    // and cannot be resumed
    _lastSessionId = null;
    _persistSessionId(null);
  }

  /// Handles session end (when the message stream closes).
  void _handleSessionEnd() {
    _t('ChatState', '_handleSessionEnd (chat=${_data.id}, isWorking=$_isWorking)');
    developer.log(
      'Session ended',
      name: 'ChatState',
    );

    _session = null;
    _isWorking = false;
    _isCompacting = false;
    _workingStartTime = null;
    _eventSubscription = null;
    _permissionSubscription = null;
    _pendingPermissions.clear();
    _activeAgents.clear();

    // Note: We intentionally do NOT clear _lastSessionId here.
    // The session ID can still be used to resume a conversation even after
    // the stream closes. Only clear it on explicit errors or user action.

    notifyListeners();
  }

  /// Converts the chat's permission mode to SDK permission mode.
  sdk.PermissionMode get _sdkPermissionMode {
    return switch (_permissionMode) {
      PermissionMode.defaultMode => sdk.PermissionMode.defaultMode,
      PermissionMode.acceptEdits => sdk.PermissionMode.acceptEdits,
      PermissionMode.plan => sdk.PermissionMode.plan,
      PermissionMode.bypass => sdk.PermissionMode.bypassPermissions,
    };
  }

  /// Sets the SDK session for this chat.
  ///
  /// This is a low-level method for testing. Prefer [startSession] for
  /// creating sessions in production code.
  @visibleForTesting
  void setSession(sdk.AgentSession? session) {
    _session = session;
    notifyListeners();
  }

  /// Marks the chat as having an active session for testing purposes.
  ///
  /// This is used in tests where we need to simulate an active session
  /// without having an actual [AgentSession] instance.
  @visibleForTesting
  void setHasActiveSessionForTesting(bool hasSession) {
    if (hasSession) {
      // For testing hasActiveSession we use a sentinel approach with a
      // test-only field rather than creating a real session.
      _testHasActiveSession = true;
    } else {
      _testHasActiveSession = false;
      _session = null;
    }
    notifyListeners();
  }

  /// Test-only flag to override hasActiveSession.
  ///
  /// When true, hasActiveSession returns true even if _session is null.
  /// This is only for testing purposes.
  // ignore: invalid_visibility_annotation
  bool _testHasActiveSession = false;

  /// Clears the SDK session and active agents.
  ///
  /// Call this when the session ends (e.g., after `/clear` command).
  /// Agents are discarded but conversations persist.
  void clearSession() {
    _session = null;
    _testHasActiveSession = false;
    _isWorking = false;
    _isCompacting = false;
    _workingStartTime = null;
    _permissionSubscription?.cancel();
    _eventSubscription?.cancel();
    _eventSubscription = null;
    _permissionSubscription = null;
    _pendingPermissions.clear();
    _activeAgents.clear();
    notifyListeners();
  }

  /// Resets the session completely for the /clear command.
  ///
  /// Stops the current session, clears the session ID so the next
  /// session starts fresh (no resume), resets the context tracker,
  /// and adds a [ContextClearedEntry] marker to the conversation.
  Future<void> resetSession() async {
    await stopSession();
    _lastSessionId = null;
    _persistSessionId(null);
    _testHasActiveSession = false;
    _isWorking = false;
    _isCompacting = false;
    _workingStartTime = null;
    resetContext();
    addEntry(ContextClearedEntry(timestamp: DateTime.now()));
    notifyListeners();
  }

  /// Clears all entries from the primary conversation.
  ///
  /// Useful for testing/replay scenarios where we want to reset state.
  void clearEntries() {
    _data = _data.copyWith(
      primaryConversation: _data.primaryConversation.copyWith(
        entries: const [],
      ),
    );
    notifyListeners();
  }

  /// Loads entries from persistence without triggering persistence writes.
  ///
  /// This is used when restoring chat history from disk. The entries are
  /// already persisted, so we don't want to re-write them.
  ///
  /// Replaces any existing entries in the primary conversation.
  void loadEntriesFromPersistence(List<OutputEntry> entries) {
    if (entries.isNotEmpty) {
      _markStarted();
    }
    _data = _data.copyWith(
      primaryConversation: _data.primaryConversation.copyWith(
        entries: List.unmodifiable(entries),
      ),
    );
    notifyListeners();
  }

  /// Whether the chat history has been loaded from persistence.
  ///
  /// Returns true if the primary conversation has any entries.
  /// Used to determine if lazy-loading is needed when a chat is selected.
  bool get hasLoadedHistory => _data.primaryConversation.entries.isNotEmpty;

  // ---------------------------------------------------------------------------
  // Context and Usage Tracking Methods
  // ---------------------------------------------------------------------------

  /// Updates context tracking from an assistant message's usage data.
  void updateContextFromUsage(Map<String, dynamic> usage) {
    _contextTracker.updateFromUsage(usage);
    // No need to notifyListeners - ContextTracker is a ChangeNotifier itself
  }

  /// Updates usage from a result message.
  ///
  /// The SDK provides session-cumulative values in `modelUsage` and
  /// `total_cost_usd`. We add the base offset from previous sessions
  /// to get the chat-wide total.
  ///
  /// For multi-session chats (e.g., after resume), [_baseUsage] and
  /// [_baseModelUsage] contain the totals from previous sessions.
  void updateCumulativeUsage({
    required UsageInfo usage,
    required double totalCostUsd,
    List<ModelUsageInfo>? modelUsage,
    int? contextWindow,
  }) {
    // The SDK's modelUsage is session-cumulative (running total).
    // Add base from previous sessions to get chat-wide totals.
    if (modelUsage != null && modelUsage.isNotEmpty) {
      // Merge session modelUsage with base modelUsage
      _modelUsage = _mergeModelUsage(_baseModelUsage, modelUsage);

      // Derive aggregate UsageInfo from merged modelUsage
      int totalInput = 0;
      int totalOutput = 0;
      int totalCacheRead = 0;
      int totalCacheCreation = 0;
      double totalCost = 0;

      for (final model in _modelUsage) {
        totalInput += model.inputTokens;
        totalOutput += model.outputTokens;
        totalCacheRead += model.cacheReadTokens;
        totalCacheCreation += model.cacheCreationTokens;
        totalCost += model.costUsd;
      }

      _cumulativeUsage = UsageInfo(
        inputTokens: totalInput,
        outputTokens: totalOutput,
        cacheReadTokens: totalCacheRead,
        cacheCreationTokens: totalCacheCreation,
        costUsd: totalCost,
      );
    }

    // Update context window max if provided
    if (contextWindow != null) {
      _contextTracker.updateMaxTokens(contextWindow);
    }

    _scheduleMetaSave();
    notifyListeners();
  }

  /// Merges base model usage with new session model usage.
  ///
  /// For each model, adds the base values to the session values.
  /// Models only in base or only in session are included as-is.
  List<ModelUsageInfo> _mergeModelUsage(
    List<ModelUsageInfo> base,
    List<ModelUsageInfo> session,
  ) {
    final result = <String, ModelUsageInfo>{};

    // Start with base values
    for (final model in base) {
      result[model.modelName] = model;
    }

    // Add session values
    for (final model in session) {
      final existing = result[model.modelName];
      if (existing != null) {
        // Add session values to base
        result[model.modelName] = ModelUsageInfo(
          modelName: model.modelName,
          inputTokens: existing.inputTokens + model.inputTokens,
          outputTokens: existing.outputTokens + model.outputTokens,
          cacheReadTokens: existing.cacheReadTokens + model.cacheReadTokens,
          cacheCreationTokens:
              existing.cacheCreationTokens + model.cacheCreationTokens,
          costUsd: existing.costUsd + model.costUsd,
          contextWindow: model.contextWindow, // Use latest
        );
      } else {
        // New model in this session
        result[model.modelName] = model;
      }
    }

    return result.values.toList();
  }

  /// Resets context tracker (e.g., after /clear command).
  void resetContext() {
    _contextTracker.reset();
  }

  /// Restores context and usage from persisted ChatMeta.
  ///
  /// Called by ProjectRestoreService when loading a chat.
  /// Sets up base usage for resume support - when a new session starts,
  /// the base values are added to the session's cumulative values.
  void restoreFromMeta(
    ContextInfo context,
    UsageInfo usage, {
    List<ModelUsageInfo> modelUsage = const [],
    TimingStats timing = const TimingStats.zero(),
  }) {
    _contextTracker.updateFromUsage({
      'input_tokens': context.currentTokens,
      'cache_creation_input_tokens': 0,
      'cache_read_input_tokens': 0,
    });
    _contextTracker.updateMaxTokens(context.maxTokens);

    // Set both current and base values from persisted state.
    // The base values are used when a new session provides cumulative data -
    // we add the base to get the chat-wide total.
    _cumulativeUsage = usage;
    _baseUsage = usage;
    _modelUsage = List.from(modelUsage);
    _baseModelUsage = List.from(modelUsage);

    // Restore timing statistics
    _timingStats = timing;

    // Don't notify - this is called during initialization
  }

  // ---------------------------------------------------------------------------
  // Persistence Methods
  // ---------------------------------------------------------------------------

  /// Persists an entry to the chat's JSONL file.
  ///
  /// Does nothing if persistence is not initialized ([_projectId] is null).
  /// Errors are logged but do not throw to avoid breaking the UI.
  Future<void> _persistEntry(OutputEntry entry) async {
    if (_projectId == null) return;
    try {
      await persistenceService.appendChatEntry(_projectId!, _data.id, entry);
    } catch (e) {
      // Log error but don't throw - persistence failures shouldn't break UI
      debugPrint('Failed to persist entry: $e');
    }
  }

  /// Persists a streaming entry that has been finalized.
  ///
  /// Called by [EventHandler] when the complete
  /// assistant message arrives and finalizes a previously streaming entry.
  /// Only persists entries belonging to the primary conversation.
  void persistStreamingEntry(OutputEntry entry) {
    _persistEntry(entry);
  }

  /// Persists a tool result to the chat's JSONL file.
  ///
  /// This is called by [EventHandler] when a tool result arrives.
  /// The result is stored as a separate [ToolResultEntry] which will be
  /// merged with the corresponding [ToolUseOutputEntry] when the history
  /// is loaded.
  ///
  /// Does nothing if persistence is not initialized.
  void persistToolResult(String toolUseId, dynamic result, bool isError) {
    if (_projectId == null) return;

    final entry = ToolResultEntry(
      timestamp: DateTime.now(),
      toolUseId: toolUseId,
      result: result,
      isError: isError,
    );

    // Fire-and-forget
    persistenceService
        .appendChatEntry(_projectId!, _data.id, entry)
        .catchError((e) {
      debugPrint('Failed to persist tool result: $e');
    });
  }

  /// Schedules a debounced save of the chat metadata.
  ///
  /// Cancels any pending save and schedules a new one for 1 second later.
  /// This prevents excessive file writes when settings change rapidly.
  void _scheduleMetaSave() {
    if (_projectId == null) return;
    _metaSaveTimer?.cancel();
    _metaSaveTimer = Timer(const Duration(seconds: 1), _saveMeta);
  }

  void _markStarted() {
    if (_hasStarted) return;
    _hasStarted = true;
    _scheduleMetaSave();
  }

  /// Saves the chat metadata to disk.
  ///
  /// Creates a [ChatMeta] from the current state and persists it.
  /// Errors are logged but do not throw to avoid breaking the UI.
  Future<void> _saveMeta() async {
    if (_projectId == null) return;
    try {
      final meta = ChatMeta(
        model: _model.id,
        backendType: _backendTypeValue,
        hasStarted: _hasStarted,
        permissionMode: _permissionMode.apiName,
        createdAt: _data.createdAt ?? DateTime.now(),
        lastActiveAt: DateTime.now(),
        context: ContextInfo(
          currentTokens: _contextTracker.currentTokens,
          maxTokens: _contextTracker.maxTokens,
        ),
        usage: _cumulativeUsage,
        modelUsage: _modelUsage,
        timing: _timingStats,
      );
      await persistenceService.saveChatMeta(_projectId!, _data.id, meta);
    } catch (e) {
      // Log error but don't throw - persistence failures shouldn't break UI
      debugPrint('Failed to save chat meta: $e');
    }
  }

  String get _backendTypeValue {
    return switch (_model.backend) {
      sdk.BackendType.codex => 'codex',
      sdk.BackendType.directCli => 'direct',
    };
  }

  /// Persists the session ID to projects.json.
  ///
  /// This is a fire-and-forget operation - errors are logged but don't block
  /// the UI. The session ID is stored in the ChatReference within projects.json
  /// to enable session resume across app restarts.
  ///
  /// Does nothing if persistence is not properly initialized (missing projectRoot
  /// or worktreePath).
  void _persistSessionId(String? sessionId) {
    if (_projectRoot == null || _worktreePath == null) {
      developer.log(
        'Cannot persist session ID: projectRoot or worktreePath is null',
        name: 'ChatState',
        level: 900, // Warning
      );
      return;
    }

    // Fire-and-forget - don't await
    persistenceService.updateChatSessionId(
      projectRoot: _projectRoot!,
      worktreePath: _worktreePath!,
      chatId: _data.id,
      sessionId: sessionId,
    );
  }

  /// Notifies listeners that the state has changed.
  ///
  /// This is exposed for use by [EventHandler]
  /// when updating entries in-place (e.g., tool result pairing).
  // ignore: unnecessary_override - purposely exposed for external use
  @override
  void notifyListeners() {
    super.notifyListeners();
  }

  @override
  void dispose() {
    // Cancel any pending meta save.
    _metaSaveTimer?.cancel();
    // Cancel stream subscriptions.
    _permissionSubscription?.cancel();
    _eventSubscription?.cancel();
    // Kill the session if active.
    _session?.kill();
    _session = null;
    _testHasActiveSession = false;
    _eventSubscription = null;
    _permissionSubscription = null;
    _pendingPermissions.clear();
    _activeAgents.clear();
    // Dispose the context tracker.
    _contextTracker.dispose();
    super.dispose();
  }
}
