import 'dart:async';
import 'dart:developer' as developer;

import 'package:claude_sdk/claude_sdk.dart' as sdk;
import 'package:flutter/foundation.dart';

import 'agent_config.dart';
import '../services/backend_service.dart';
import '../services/log_service.dart';
import '../services/notification_service.dart';
import '../services/persistence_models.dart';
import '../services/persistence_service.dart';
import '../services/runtime_config.dart';
import '../services/event_handler.dart';
import '../services/internal_tools_service.dart';
import 'agent.dart';
import 'chat_model.dart';
import 'context_tracker.dart';
import 'conversation.dart';
import 'output_entry.dart';
import 'timing_stats.dart';

part 'chat_state/chat_agent_state.dart';
part 'chat_state/chat_conversation_state.dart';
part 'chat_state/chat_metrics_state.dart';
part 'chat_state/chat_persistence_state.dart';
part 'chat_state/chat_permission_state.dart';
part 'chat_state/chat_session_state.dart';
part 'chat_state/chat_settings_state.dart';
part 'chat_state/chat_view_state.dart';

/// Diagnostic trace â€” only prints when [sdk.SdkLogger.debugEnabled] is true.
void _t(String tag, String msg) => sdk.SdkLogger.instance.trace(tag, msg);

/// Permission modes for tool execution.
enum PermissionMode {
  /// Requires permission for most operations.
  defaultMode('Default', 'default'),

  /// Auto-approves file operations within project directory.
  acceptEdits('Accept Edits', 'acceptEdits'),

  /// Planning mode with restricted tool access.
  plan('Plan Only', 'plan'),

  /// Dangerous: approves everything without asking.
  bypass('Bypass All', 'bypassPermissions');

  const PermissionMode(this.label, this.apiName);

  /// Display label for the mode.
  final String label;

  /// API name sent to the backend.
  final String apiName;

  /// Finds a [PermissionMode] by its API name string.
  ///
  /// Falls back to [defaultMode] if no match is found.
  static PermissionMode fromApiName(String apiName) {
    return PermissionMode.values.firstWhere(
      (p) => p.apiName == apiName,
      orElse: () => PermissionMode.defaultMode,
    );
  }
}

/// Lifecycle phases for a chat session.
enum SessionPhase { idle, starting, active, stopping, ended, errored }

/// Immutable data class representing a chat.
///
/// A chat is a user-facing conversation unit that belongs to a worktree.
/// It contains a primary conversation for user interaction and zero or more
/// subagent conversations that are read-only.
///
/// Use [copyWith] to create modified copies of this immutable class.
@immutable
class ChatData {
  /// Unique identifier for this chat.
  final String id;

  /// User-visible name for this chat.
  final String name;

  /// The path to the worktree this chat belongs to.
  ///
  /// This references the parent worktree's root directory.
  /// May be null for testing or standalone chats.
  final String? worktreeRoot;

  /// Whether the chat name was auto-generated from the first message.
  ///
  /// When true, the name should be replaced with an AI-generated title
  /// after the first assistant response.
  final bool isAutoGeneratedName;

  /// When this chat was created.
  /// May be null for testing chats.
  final DateTime? createdAt;

  /// The primary conversation for this chat.
  ///
  /// Users interact with this conversation via the input box. It is always
  /// present and allows user input.
  final ConversationData primaryConversation;

  /// Subagent conversations keyed by conversation ID.
  ///
  /// These are created when the SDK spawns subagents via the Task tool.
  /// Subagent conversations are read-only - users cannot send input to them.
  final Map<String, ConversationData> subagentConversations;

  /// Creates a [ChatData] instance.
  const ChatData({
    required this.id,
    required this.name,
    this.worktreeRoot,
    this.isAutoGeneratedName = false,
    this.createdAt,
    required this.primaryConversation,
    this.subagentConversations = const {},
  });

  /// Creates a new chat with default values.
  ///
  /// Generates a unique ID and creates an empty primary conversation.
  /// If [isAutoGeneratedName] is true, the name may be replaced with an
  /// AI-generated title after the first assistant response.
  factory ChatData.create({
    required String name,
    required String worktreeRoot,
    bool isAutoGeneratedName = false,
  }) {
    final id = 'chat-${DateTime.now().millisecondsSinceEpoch}';
    return ChatData(
      id: id,
      name: name,
      worktreeRoot: worktreeRoot,
      isAutoGeneratedName: isAutoGeneratedName,
      createdAt: DateTime.now(),
      primaryConversation: ConversationData.primary(id: 'conv-primary-$id'),
      subagentConversations: const {},
    );
  }

  /// Returns all conversations in this chat.
  ///
  /// The primary conversation is always first, followed by subagent
  /// conversations in no particular order.
  List<ConversationData> get allConversations => [
    primaryConversation,
    ...subagentConversations.values,
  ];

  /// Creates a copy with the given fields replaced.
  ChatData copyWith({
    String? id,
    String? name,
    String? worktreeRoot,
    bool? isAutoGeneratedName,
    DateTime? createdAt,
    ConversationData? primaryConversation,
    Map<String, ConversationData>? subagentConversations,
  }) {
    return ChatData(
      id: id ?? this.id,
      name: name ?? this.name,
      worktreeRoot: worktreeRoot ?? this.worktreeRoot,
      isAutoGeneratedName: isAutoGeneratedName ?? this.isAutoGeneratedName,
      createdAt: createdAt ?? this.createdAt,
      primaryConversation: primaryConversation ?? this.primaryConversation,
      subagentConversations:
          subagentConversations ?? this.subagentConversations,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ChatData &&
        other.id == id &&
        other.name == name &&
        other.worktreeRoot == worktreeRoot &&
        other.isAutoGeneratedName == isAutoGeneratedName &&
        other.createdAt == createdAt &&
        other.primaryConversation == primaryConversation &&
        mapEquals(other.subagentConversations, subagentConversations);
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      name,
      worktreeRoot,
      isAutoGeneratedName,
      createdAt,
      primaryConversation,
      Object.hashAll(subagentConversations.entries),
    );
  }

  @override
  String toString() {
    return 'ChatData(id: $id, name: $name, worktreeRoot: $worktreeRoot, '
        'isAutoGeneratedName: $isAutoGeneratedName, createdAt: $createdAt, '
        'subagentConversations: ${subagentConversations.length})';
  }
}

/// Plain chat container.
///
/// Holds references to all sub-states and exposes immutable chat identity data.
/// Runtime behavior is implemented by the internal [_ChatCore].
class Chat {
  final _ChatCore _core;

  Chat(ChatData data, {String? agentId})
    : _core = _ChatCore(data, agentId: agentId) {
    _core._facade = this;
  }

  factory Chat.create({
    required String name,
    required String worktreeRoot,
    bool isAutoGeneratedName = false,
    String? agentId,
  }) {
    return Chat(
      ChatData.create(
        name: name,
        worktreeRoot: worktreeRoot,
        isAutoGeneratedName: isAutoGeneratedName,
      ),
      agentId: agentId,
    );
  }

  ChatSessionState get session => _core.session;
  ChatPermissionState get permissions => _core.permissions;
  ChatSettingsState get settings => _core.settings;
  ChatMetricsState get metrics => _core.metrics;
  ChatPersistenceState get persistence => _core.persistence;
  ChatAgentState get agents => _core.agents;
  ChatConversationState get conversations => _core.conversations;
  ChatViewState get viewState => _core.viewState;

  ChatData get data => _core.data;
  String get id => data.id;
  String get name => data.name;

  void dispose() {
    _core.dispose();
  }
}

/// Runtime core for [Chat].
///
/// Owns mutable state and side-effectful orchestration while the public [Chat]
/// remains a plain container.
class _ChatCore extends ChangeNotifier {
  late Chat _facade;
  ChatData _data;

  /// Compatibility facade sub-states for phased Chat decomposition.
  ///
  /// Chunk A scaffolding: these delegate to existing Chat behavior so
  /// consumers can migrate incrementally without behavior changes.
  late final ChatSessionState session;
  late final ChatPermissionState permissions;
  late final ChatSettingsState settings;
  late final ChatMetricsState metrics;
  late final ChatPersistenceState persistence;
  late final ChatAgentState agents;
  late final ChatConversationState conversations;
  late final ChatViewState viewState;

  /// The SDK session for this chat.
  ///
  /// Null when no session is active. Kept as a reference for test
  /// compatibility via [setSession]. Production code uses [_transport].
  sdk.AgentSession? _session;

  /// The transport wrapping the session.
  ///
  /// Null when no session is active. This is the primary interface for
  /// sending commands and receiving events.
  sdk.EventTransport? _transport;

  /// Subscription to the transport's events stream (for EventHandler).
  StreamSubscription<sdk.InsightsEvent>? _eventSubscription;

  /// The event handler for this chat's session.
  ///
  /// Set when a session starts, cleared when it ends. Used to notify
  /// the handler of permission responses for ticket status transitions.
  EventHandler? _eventHandler;

  /// Subscription to the transport's permission request stream.
  StreamSubscription<sdk.PermissionRequest>? _permissionSubscription;

  /// Queue of pending permission requests.
  ///
  /// Multiple permission requests can arrive concurrently (e.g., when Claude
  /// is working on parallel tasks). This queue ensures all requests are
  /// displayed to the user in order, rather than only showing the most recent.
  final List<sdk.PermissionRequest> _pendingPermissions = [];

  /// Whether Claude is currently working (processing a request).
  ///
  /// True when a session is active and Claude is generating a response.
  /// Set to true when a message is sent, set to false when a result or
  /// error is received.
  bool _isWorking = false;

  /// Stopwatch tracking how long Claude has been working.
  ///
  /// Started when [_isWorking] becomes true, stopped and cleared when it
  /// becomes false. Uses monotonic clock time so it doesn't count time
  /// spent in system sleep/suspend.
  Stopwatch? _workingStopwatch;

  /// Whether the context is currently being compacted.
  ///
  /// True when compaction has started (status: "compacting" received),
  /// false when compaction ends (status: null received).
  bool _isCompacting = false;

  /// Session lifecycle phase.
  SessionPhase _sessionPhase = SessionPhase.idle;

  /// In-flight teardown future to keep teardown idempotent.
  Future<void>? _teardownInFlight;

  /// Active agents keyed by SDK agent ID.
  ///
  /// Agents are runtime-only and are discarded when the session ends.
  /// Maps SDK agent IDs to [Agent] instances.
  final Map<String, Agent> _activeAgents = {};

  /// The ID of the currently selected conversation.
  ///
  /// Null means the primary conversation is selected.
  String? _selectedConversationId;

  /// The selected model for this chat.
  ChatModel _model = ChatModelCatalog.defaultFromComposite(
    RuntimeConfig.instance.defaultModel,
    fallbackBackend: RuntimeConfig.instance.defaultBackend,
  );

  /// Backend-specific security configuration.
  late sdk.SecurityConfig _securityConfig;

  /// The reasoning effort level for this chat (Codex only).
  ///
  /// Controls how much reasoning the model does before responding.
  /// Only applicable when the backend is Codex. Null means use the default.
  sdk.ReasoningEffort? _reasoningEffort;

  /// Capabilities of the backend this chat is using.
  ///
  /// Set when a session starts. Used to guard mid-session calls so that
  /// unsupported operations (e.g., setReasoningEffort on CLI) are never
  /// sent to the backend.
  sdk.BackendCapabilities _capabilities = const sdk.BackendCapabilities();

  /// ACP session configuration options, if provided.
  List<Map<String, dynamic>>? _acpConfigOptions;

  /// ACP available commands, if provided.
  List<Map<String, dynamic>>? _acpAvailableCommands;

  /// ACP current mode ID, if provided.
  String? _acpCurrentModeId;

  /// ACP available modes, if provided.
  List<Map<String, dynamic>>? _acpAvailableModes;

  /// The last SDK session ID for this chat, used for session resume.
  ///
  /// Set when a session is created successfully.
  /// Cleared when a session ends or errors out.
  /// Persisted to projects.json for resume across app restarts.
  String? _lastSessionId;

  /// Whether this chat has started at least once.
  ///
  /// Once true, the backend is locked for this chat even if the session ends.
  bool _hasStarted = false;

  /// Whether the chat history has been loaded from persistence.
  ///
  /// Used to determine if lazy-loading is needed. Independent of entry count
  /// since security config changes can add notification entries during restore.
  bool _historyLoaded = false;

  /// The worktree path for this chat.
  ///
  /// Comes from ChatData.worktreeRoot but stored separately for persistence.
  String? get _worktreePath => _data.worktreeRoot;

  /// Context window tracking for this chat.
  final ContextTracker _contextTracker = ContextTracker();

  /// Cumulative usage for this chat across all sessions.
  ///
  /// Updated authoritatively by [updateCumulativeUsage] at end of each turn.
  UsageInfo _cumulativeUsage = const UsageInfo.zero();

  /// Running output token count accumulated during the current turn.
  ///
  /// Each [UsageUpdateEvent] (from main agent and subagents) adds its
  /// output_tokens here. This allows the cost indicator to show progress
  /// mid-turn. Reset to 0 when [updateCumulativeUsage] overwrites with
  /// authoritative totals from the result message.
  int _inTurnOutputTokens = 0;

  /// Per-model usage breakdown for this chat.
  List<ModelUsageInfo> _modelUsage = [];

  /// Timing statistics for this chat (Claude working time, user response time).
  TimingStats _timingStats = const TimingStats.zero();

  /// Timestamps for when each permission request was received.
  ///
  /// Keyed by the permission request's toolUseId. When a permission is
  /// allowed or denied, the elapsed time is added to [_timingStats].
  final Map<String, DateTime> _permissionRequestTimes = {};

  /// Base per-model usage from previous sessions (for resume support).
  List<ModelUsageInfo> _baseModelUsage = [];

  /// The agent configuration ID for this chat.
  ///
  /// References an [AgentConfig.id] from the agent registry.
  /// When set, session creation uses agent-keyed backend methods.
  /// Null for legacy chats that predate the agent system.
  String? _agentId;

  /// Whether this chat's agent was removed from the agent registry.
  ///
  /// When true, the chat remains visible (history preserved) but no new
  /// sessions can be started and the message input is disabled.
  bool _agentRemoved = false;

  /// Descriptive message when the chat's agent is missing from the registry.
  ///
  /// Non-null when the chat was restored but neither the original agentId
  /// was found nor a matching agent by name+driver exists.
  String? _missingAgentMessage;

  /// The persistence service instance.
  ///
  /// Can be overridden for testing.
  @visibleForTesting
  PersistenceService persistenceService = PersistenceService();

  /// Creates a [Chat] with the given data.
  _ChatCore(this._data, {String? agentId}) : _agentId = agentId {
    _initializeCompatibilityFacade();
    final effectiveAgentId = _agentId;
    if (effectiveAgentId != null) {
      // Initialize security config from agent config
      final agentConfig = RuntimeConfig.instance.agentById(effectiveAgentId);
      if (agentConfig != null) {
        _initSecurityConfigFromAgent(agentConfig);
        return;
      }
    }
    // Fallback: use default backend-based initialization
    final defaultBackend = RuntimeConfig.instance.defaultBackend;
    if (defaultBackend == sdk.BackendType.codex) {
      _securityConfig = const sdk.CodexSecurityConfig(
        sandboxMode: sdk.CodexSandboxMode.workspaceWrite,
        approvalPolicy: sdk.CodexApprovalPolicy.onRequest,
      );
    } else {
      _securityConfig = sdk.ClaudeSecurityConfig(
        permissionMode: sdk.PermissionMode.fromString(
          RuntimeConfig.instance.defaultPermissionMode,
        ),
      );
    }
  }

  void _initializeCompatibilityFacade() {
    session = ChatSessionState._(this);
    permissions = ChatPermissionState._(this);
    settings = ChatSettingsState._(this);
    metrics = ChatMetricsState._(this);
    persistence = ChatPersistenceState._(this);
    agents = ChatAgentState._(this);
    conversations = ChatConversationState._(this);
    viewState = ChatViewState._(this);
  }

  /// Initializes security config based on agent configuration.
  void _initSecurityConfigFromAgent(AgentConfig config) {
    if (config.driver == 'codex') {
      _securityConfig = sdk.CodexSecurityConfig(
        sandboxMode: sdk.CodexSandboxMode.fromNameOrWire(
          config.codexSandboxMode ?? 'workspace-write',
        ),
        approvalPolicy: sdk.CodexApprovalPolicy.fromNameOrWire(
          config.codexApprovalPolicy ?? 'on-request',
        ),
      );
    } else {
      _securityConfig = sdk.ClaudeSecurityConfig(
        permissionMode: sdk.PermissionMode.fromString(
          config.defaultPermissions.isEmpty
              ? 'default'
              : config.defaultPermissions,
        ),
      );
    }
  }

  /// Creates a new [Chat] with a newly created chat.
  ///
  /// If [isAutoGeneratedName] is true, the name may be replaced with an
  /// AI-generated title after the first assistant response.
  factory _ChatCore.create({
    required String name,
    required String worktreeRoot,
    bool isAutoGeneratedName = false,
    String? agentId,
  }) {
    return _ChatCore(
      ChatData.create(
        name: name,
        worktreeRoot: worktreeRoot,
        isAutoGeneratedName: isAutoGeneratedName,
      ),
      agentId: agentId,
    );
  }

  /// Initializes persistence for this chat.
  ///
  /// Must be called after the chat is associated with a project.
  /// Creates the necessary directories for persistence.
  ///
  /// The [projectId] is used to locate the persistence directory.
  /// The [projectRoot] is the absolute path to the project root, used for
  /// updating lastSessionId in projects.json.
  ///
  /// When persistence is initialized:
  /// - New entries are automatically appended to the JSONL file
  /// - Model/permission changes trigger debounced meta saves
  /// - Session ID changes update projects.json
  Future<void> initPersistence(String projectId, {String? projectRoot}) async {
    await persistence.initPersistence(projectId, projectRoot: projectRoot);
  }

  /// The project ID for persistence, if initialized.
  ///
  /// Returns null if persistence has not been initialized.
  String? get projectId => persistence.projectId;

  /// Context window tracking for this chat.
  ContextTracker get contextTracker => metrics.contextTracker;

  /// Cumulative usage for this chat across all sessions.
  ///
  /// Includes in-turn output tokens accumulated from [UsageUpdateEvent]s
  /// so that the cost indicator updates during long turns. When the turn
  /// completes, [updateCumulativeUsage] replaces this with authoritative
  /// totals and resets the in-turn accumulator.
  UsageInfo get cumulativeUsage => metrics.cumulativeUsage;

  /// Per-model usage breakdown from the last result message.
  List<ModelUsageInfo> get modelUsage => metrics.modelUsage;

  /// Timing statistics for this chat.
  ///
  /// Tracks how long Claude has spent working and how long the user took
  /// to respond to prompts.
  TimingStats get timingStats => metrics.timingStats;

  /// The immutable chat data.
  ChatData get data => _data;

  /// The agent configuration ID for this chat, or null for legacy chats.
  String? get agentId => _agentId;

  /// Whether this chat's agent was removed from the registry.
  ///
  /// When true, the chat history is preserved but no new messages can be sent.
  bool get agentRemoved => _agentRemoved;

  /// Descriptive message explaining why the agent is missing.
  ///
  /// Null when the agent is present or was actively removed (uses the
  /// generic agent-removed message instead).
  String? get missingAgentMessage => _missingAgentMessage;

  /// Marks this chat as having a missing agent.
  ///
  /// Sets the [agentRemoved] flag and stores a descriptive message.
  /// Called by [ProjectRestoreService] when the agent cannot be resolved.
  void markAgentMissing(String message) {
    _agentRemoved = true;
    _missingAgentMessage = message;
    agents.notifyListeners();
  }

  /// Sets the agent ID for this chat.
  ///
  /// Used when switching agents on a chat that hasn't started yet.
  set agentId(String? value) {
    if (_agentId != value) {
      _agentId = value;
      agents.notifyListeners();
    }
  }

  /// The display name of the agent for this chat.
  ///
  /// Resolves from the agent registry if [agentId] is set. Falls back to
  /// the driver-based label if the agent is not found.
  String get agentName {
    final id = _agentId;
    if (id != null) {
      final config = RuntimeConfig.instance.agentById(id);
      if (config != null) return config.name;
    }
    // Fallback for legacy chats or missing agents
    return backendLabel;
  }

  /// Whether there is an active SDK session.
  bool get hasActiveSession =>
      _transport != null || _session != null || _testHasActiveSession;

  /// Current lifecycle phase for this chat's session.
  SessionPhase get sessionPhase => _sessionPhase;

  /// Whether the chat is waiting for a permission response from the user.
  bool get isWaitingForPermission => _pendingPermissions.isNotEmpty;

  /// The currently pending permission request, if any.
  ///
  /// Returns the first request in the queue (FIFO order).
  sdk.PermissionRequest? get pendingPermission =>
      _pendingPermissions.isNotEmpty ? _pendingPermissions.first : null;

  /// The number of pending permission requests in the queue.
  int get pendingPermissionCount => _pendingPermissions.length;

  /// Whether Claude is currently working (processing a request).
  ///
  /// True when a session is active and Claude is generating a response.
  bool get isWorking => _isWorking;

  /// Stopwatch tracking active working time, or null if not working.
  ///
  /// Uses monotonic clock so elapsed time excludes system sleep/suspend.
  /// Used by the UI to display elapsed time in the working indicator.
  Stopwatch? get workingStopwatch => _workingStopwatch;

  /// Whether the context is currently being compacted.
  ///
  /// When true, the UI should show "Compacting context..." instead of
  /// the regular "Claude is working" indicator.
  bool get isCompacting => _isCompacting;

  /// The currently active agents.
  ///
  /// Returns an unmodifiable view of the active agents map.
  Map<String, Agent> get activeAgents => Map.unmodifiable(_activeAgents);

  /// The currently selected conversation.
  ///
  /// Returns the primary conversation if [_selectedConversationId] is null,
  /// otherwise returns the subagent conversation with that ID.
  ConversationData get selectedConversation {
    if (_selectedConversationId == null) {
      return _data.primaryConversation;
    }
    return _data.subagentConversations[_selectedConversationId] ??
        _data.primaryConversation;
  }

  /// Whether user input is enabled for the current selection.
  ///
  /// Input is only enabled when viewing the primary conversation
  /// and the agent has not been removed.
  bool get isInputEnabled => _selectedConversationId == null && !_agentRemoved;

  /// The selected model for this chat.
  ChatModel get model => _model;

  /// The backend-specific security configuration for this chat.
  sdk.SecurityConfig get securityConfig => _securityConfig;

  /// The permission mode for this chat.
  ///
  /// For Claude chats, returns the permission mode from the security config.
  /// For Codex chats, returns the default mode for backward compatibility.
  PermissionMode get permissionMode {
    if (_securityConfig case sdk.ClaudeSecurityConfig(:final permissionMode)) {
      return PermissionMode.fromApiName(permissionMode.value);
    }
    return PermissionMode.defaultMode;
  }

  /// The reasoning effort level for this chat (Codex only).
  ///
  /// Returns null if using the default effort level or if not applicable.
  sdk.ReasoningEffort? get reasoningEffort => _reasoningEffort;

  /// Capabilities of the backend this chat is using.
  ///
  /// Updated when a session starts. Before the first session, returns
  /// an empty capabilities object (all false).
  sdk.BackendCapabilities get capabilities => _capabilities;

  /// ACP session config options (if provided by the backend).
  List<Map<String, dynamic>>? get acpConfigOptions => _acpConfigOptions;

  /// ACP available commands (if provided by the backend).
  List<Map<String, dynamic>>? get acpAvailableCommands => _acpAvailableCommands;

  /// ACP current mode ID (if provided by the backend).
  String? get acpCurrentModeId => _acpCurrentModeId;

  /// ACP available modes (if provided by the backend).
  List<Map<String, dynamic>>? get acpAvailableModes => _acpAvailableModes;

  /// The last SDK session ID for this chat, used for session resume.
  ///
  /// Null if no session has been started, or if the last session ended.
  String? get lastSessionId => _lastSessionId;

  /// Whether this chat has started at least once.
  bool get hasStarted => _hasStarted;

  /// Whether the chat name was auto-generated and should be replaced.
  bool get isAutoGeneratedName => _data.isAutoGeneratedName;

  /// Whether this chat has unread messages.
  ///
  /// True when messages have arrived while the chat was not being viewed.
  bool get hasUnreadMessages => viewState.hasUnreadMessages;

  /// The number of unread messages in this chat.
  int get unreadCount => viewState.unreadCount;

  /// Draft text being typed in the message input.
  ///
  /// Preserved across chat switches via [ChatViewState].
  String get draftText => viewState.draftText;
  set draftText(String value) => viewState.draftText = value;

  /// Sets the last session ID for this chat.
  ///
  /// Called by [ProjectRestoreService] when restoring a chat from persistence.
  /// This allows the session ID to be restored without triggering a persistence
  /// save (since it's already persisted).
  void setLastSessionIdFromRestore(String? sessionId) {
    _lastSessionId = sessionId;
  }

  /// Sets the started flag when restoring from persistence.
  ///
  /// Used to lock the backend selector for existing chats.
  void setHasStartedFromRestore(bool hasStarted) {
    if (hasStarted) {
      _hasStarted = true;
    }
  }

  /// Marks this chat as being viewed.
  ///
  /// Resets the unread count to 0 and sets the viewing flag.
  /// Call this when the chat is selected in the UI.
  void markAsViewed() {
    viewState.markAsViewed();
  }

  /// Marks this chat as no longer being viewed.
  ///
  /// Call this when a different chat is selected or the chat panel is closed.
  void markAsNotViewed() {
    viewState.markAsNotViewed();
  }

  /// Increments the unread message counter.
  ///
  /// Only increments if the chat is not currently being viewed.
  /// Called when new messages arrive from the SDK.
  void _incrementUnread() {
    viewState.incrementUnread();
  }

  /// Sets the model for this chat.
  ///
  /// If a session is active and supports mid-session model changes, this also
  /// updates the model on the running session.
  void setModel(ChatModel model) {
    if (_model != model) {
      // Check if the backend type is changing
      final backendChanged = model.backend != _model.backend;

      // If backend changed, update security config to match new backend
      if (backendChanged) {
        if (model.backend == sdk.BackendType.codex) {
          _securityConfig = const sdk.CodexSecurityConfig(
            sandboxMode: sdk.CodexSandboxMode.workspaceWrite,
            approvalPolicy: sdk.CodexApprovalPolicy.onRequest,
          );
        } else {
          _securityConfig = sdk.ClaudeSecurityConfig(
            permissionMode: sdk.PermissionMode.fromString(
              RuntimeConfig.instance.defaultPermissionMode,
            ),
          );
        }
      }

      _model = model;
      _scheduleMetaSave();
      // Update the model on the active transport if one exists
      if (_transport != null) {
        final sessionId = _transport!.sessionId ?? '';
        _transport!.send(
          sdk.SetModelCommand(
            sessionId: sessionId,
            model: model.id.isEmpty ? 'default' : model.id,
          ),
        );
      }
      settings.notifyListeners();
    }
  }

  /// Sets the permission mode for this chat.
  ///
  /// If a session is active and the backend supports mid-session permission
  /// changes, this also updates the permission mode on the running session.
  /// If the backend does not support permission mode changes, the value is
  /// stored locally but not sent to the session.
  void setPermissionMode(PermissionMode mode) {
    final sdkMode = _toSdkPermissionMode(mode);
    setSecurityConfig(sdk.ClaudeSecurityConfig(permissionMode: sdkMode));
  }

  /// Sets the security configuration for this chat.
  ///
  /// If a session is active and the backend supports mid-session config changes,
  /// this also updates the configuration on the running session.
  ///
  /// If [notifyChange] is false, no notification entry is added even if the
  /// config changed. Used during restore to avoid spurious notifications.
  void setSecurityConfig(
    sdk.SecurityConfig config, {
    bool notifyChange = true,
  }) {
    if (_securityConfig == config) return;
    final oldConfig = _securityConfig;
    _securityConfig = config;
    _scheduleMetaSave();

    // Generate change notification (unless restoring from persistence)
    if (notifyChange) {
      final message = _describeSecurityChange(oldConfig, config);
      if (message != null) {
        addEntry(
          SystemNotificationEntry(timestamp: DateTime.now(), message: message),
        );
      }
    }

    switch (config) {
      case sdk.ClaudeSecurityConfig(:final permissionMode):
        if (_capabilities.supportsPermissionModeChange && _transport != null) {
          final sessionId = _transport!.sessionId ?? '';
          _transport!.send(
            sdk.SetPermissionModeCommand(
              sessionId: sessionId,
              mode: permissionMode.value,
            ),
          );
        }
      case sdk.CodexSecurityConfig():
        // Mid-session Codex config changes will be handled in a future task
        break;
    }

    settings.notifyListeners();
  }

  /// Updates ACP config options from the backend.
  void setAcpConfigOptions(List<Map<String, dynamic>> options) {
    _acpConfigOptions = _freezeMapList(options);
    settings.notifyListeners();
  }

  /// Sends an ACP config option update to the backend.
  void setAcpConfigOption({required String configId, required dynamic value}) {
    if (_transport != null) {
      final sessionId = _transport!.sessionId ?? '';
      _transport!.send(
        sdk.SetConfigOptionCommand(
          sessionId: sessionId,
          configId: configId,
          value: value,
        ),
      );
      return;
    }
    if (_session != null) {
      _session!.setConfigOption(configId, value);
    }
  }

  /// Updates ACP available commands from the backend.
  void setAcpAvailableCommands(List<Map<String, dynamic>> commands) {
    _acpAvailableCommands = _freezeMapList(commands);
    settings.notifyListeners();
  }

  /// Updates ACP session modes from the backend.
  void setAcpSessionMode({
    required String currentModeId,
    List<Map<String, dynamic>>? availableModes,
  }) {
    _acpCurrentModeId = currentModeId;
    if (availableModes != null) {
      _acpAvailableModes = _freezeMapList(availableModes);
    }
    settings.notifyListeners();
  }

  /// Sends an ACP mode update to the backend.
  void setAcpMode(String modeId) {
    if (_transport != null) {
      final sessionId = _transport!.sessionId ?? '';
      _transport!.send(
        sdk.SetPermissionModeCommand(sessionId: sessionId, mode: modeId),
      );
      return;
    }
    if (_session != null) {
      _session!.setPermissionMode(modeId);
    }
  }

  void _clearAcpSessionMetadata() {
    _acpConfigOptions = null;
    _acpAvailableCommands = null;
    _acpCurrentModeId = null;
    _acpAvailableModes = null;
  }

  /// Disposes per-session EventHandler routing state for this chat.
  void _clearEventHandlerState() {
    _eventHandler?.endSession(_data.id);
  }

  List<Map<String, dynamic>> _freezeMapList(List<Map<String, dynamic>> input) {
    return List.unmodifiable(
      input.map((entry) => Map<String, dynamic>.from(entry)).toList(),
    );
  }

  /// Describes a security configuration change.
  ///
  /// Returns a user-friendly message describing what changed, or null if
  /// there is no meaningful change to report.
  String? _describeSecurityChange(
    sdk.SecurityConfig old,
    sdk.SecurityConfig newConfig,
  ) {
    if (old is sdk.CodexSecurityConfig &&
        newConfig is sdk.CodexSecurityConfig) {
      final parts = <String>[];
      if (old.sandboxMode != newConfig.sandboxMode) {
        parts.add('Sandbox changed to ${_sandboxLabel(newConfig.sandboxMode)}');
      }
      if (old.approvalPolicy != newConfig.approvalPolicy) {
        parts.add(
          'Approval policy set to ${_policyLabel(newConfig.approvalPolicy)}',
        );
      }
      return parts.isEmpty ? null : parts.join('. ');
    }
    if (old is sdk.ClaudeSecurityConfig &&
        newConfig is sdk.ClaudeSecurityConfig) {
      if (old.permissionMode != newConfig.permissionMode) {
        return 'Permission mode changed to ${newConfig.permissionMode.value}';
      }
    }
    return null;
  }

  /// Returns a display label for a sandbox mode.
  String _sandboxLabel(sdk.CodexSandboxMode mode) {
    return switch (mode) {
      sdk.CodexSandboxMode.readOnly => 'Read Only',
      sdk.CodexSandboxMode.workspaceWrite => 'Workspace Write',
      sdk.CodexSandboxMode.dangerFullAccess => 'Full Access',
    };
  }

  /// Returns a display label for an approval policy.
  String _policyLabel(sdk.CodexApprovalPolicy policy) {
    return switch (policy) {
      sdk.CodexApprovalPolicy.untrusted => 'Untrusted',
      sdk.CodexApprovalPolicy.onRequest => 'On Request',
      sdk.CodexApprovalPolicy.onFailure => 'On Failure',
      sdk.CodexApprovalPolicy.never => 'Never',
    };
  }

  /// Converts a [PermissionMode] to SDK permission mode.
  sdk.PermissionMode _toSdkPermissionMode(PermissionMode mode) {
    return switch (mode) {
      PermissionMode.defaultMode => sdk.PermissionMode.defaultMode,
      PermissionMode.acceptEdits => sdk.PermissionMode.acceptEdits,
      PermissionMode.plan => sdk.PermissionMode.plan,
      PermissionMode.bypass => sdk.PermissionMode.bypassPermissions,
    };
  }

  /// Sets the reasoning effort level for this chat.
  ///
  /// If a session is active and the backend supports reasoning effort, this
  /// also updates the reasoning effort on the running session. If the backend
  /// does not support reasoning effort, the value is stored locally but not
  /// sent to the session.
  ///
  /// Pass null to use the default effort level.
  void setReasoningEffort(sdk.ReasoningEffort? effort) {
    if (_reasoningEffort != effort) {
      _reasoningEffort = effort;
      _scheduleMetaSave();
      if (_capabilities.supportsReasoningEffort && _transport != null) {
        final sessionId = _transport!.sessionId ?? '';
        _transport!.send(
          sdk.SetReasoningEffortCommand(
            sessionId: sessionId,
            effort: effort?.value ?? 'default',
          ),
        );
      }
      settings.notifyListeners();
    }
  }

  /// Updates the displayed model from a server-reported value.
  ///
  /// Unlike [setModel], this does NOT send a command back to the session.
  /// Used when the server reports the resolved model (e.g. in SessionInitEvent).
  void syncModelFromServer(ChatModel model) {
    if (_model != model) {
      _model = model;
      _scheduleMetaSave();
      settings.notifyListeners();
    }
  }

  /// Updates the displayed reasoning effort from a server-reported value.
  ///
  /// Unlike [setReasoningEffort], this does NOT send a command back to the
  /// session. Used when the server reports the active reasoning effort.
  void syncReasoningEffortFromServer(sdk.ReasoningEffort? effort) {
    if (_reasoningEffort != effort) {
      _reasoningEffort = effort;
      _scheduleMetaSave();
      settings.notifyListeners();
    }
  }

  /// Syncs server-reported model and reasoning effort from the transport.
  ///
  /// Called immediately after transport creation to pick up values that were
  /// reported by the server in the session creation response. These arrive
  /// before the event stream is subscribed, so they can't be handled via
  /// [SessionInitEvent].
  void _syncServerReportedValues(sdk.EventTransport transport) {
    final serverModel = transport.serverModel;
    if (serverModel != null && serverModel.isNotEmpty) {
      final models = ChatModelCatalog.forBackend(_model.backend);
      final match = models.where((m) => m.id == serverModel).toList();
      if (match.isNotEmpty) {
        syncModelFromServer(match.first);
      } else {
        syncModelFromServer(
          ChatModel(
            id: serverModel,
            label: serverModel,
            backend: _model.backend,
          ),
        );
      }
    }

    final serverEffort = transport.serverReasoningEffort;
    if (serverEffort != null) {
      final effort = sdk.ReasoningEffort.fromString(serverEffort);
      if (effort != null) {
        syncReasoningEffortFromServer(effort);
      }
    }
  }

  /// Renames this chat.
  ///
  /// Updates the in-memory state and persists the new name to projects.json.
  /// Also clears the [isAutoGeneratedName] flag since the name is now explicit.
  void rename(String newName) {
    LogService.instance.info(
      'Chat',
      'Chat renamed: "${_data.name}" -> "$newName"',
    );
    _data = _data.copyWith(name: newName, isAutoGeneratedName: false);
    conversations.notifyListeners();
    _persistRename(newName);
  }

  /// Persists the chat rename to projects.json.
  ///
  /// Does nothing if persistence is not properly initialized.
  void _persistRename(String newName) {
    persistence.persistRename(newName);
  }

  /// Selects a conversation within this chat.
  ///
  /// Pass null to select the primary conversation.
  /// Pass a conversation ID to select a subagent conversation.
  void selectConversation(String? conversationId) {
    if (_selectedConversationId != conversationId) {
      _selectedConversationId = conversationId;
      conversations.notifyListeners();
    }
  }

  /// Resets conversation selection to the primary conversation.
  ///
  /// Called when this chat is selected to ensure the user sees
  /// the main conversation first.
  void resetToMainConversation() {
    if (_selectedConversationId != null) {
      _selectedConversationId = null;
      conversations.notifyListeners();
    }
  }

  /// Adds a new subagent conversation.
  ///
  /// Creates a new conversation with the given label and task description,
  /// and creates a corresponding [Agent] linked to it.
  ///
  /// The [sdkAgentId] is the SDK's internal agent identifier used to route
  /// messages to the correct agent.
  ///
  /// The [label] is the subagent type (e.g., "general-purpose", "Explore").
  /// The [taskDescription] is a short summary of what the agent will do.
  String addSubagentConversation(String? label, String? taskDescription) {
    final conversationId = 'conv-${DateTime.now().millisecondsSinceEpoch}';
    // Count existing subagents to generate a fallback label
    final subagentNumber = _data.subagentConversations.length + 1;
    final conversation = ConversationData.subagent(
      id: conversationId,
      label: label,
      taskDescription: taskDescription,
      subagentNumber: subagentNumber,
    );

    _data = _data.copyWith(
      subagentConversations: {
        ..._data.subagentConversations,
        conversationId: conversation,
      },
    );
    conversations.notifyListeners();
    return conversationId;
  }

  /// Updates an agent's status.
  ///
  /// The [sdkAgentId] identifies which agent to update.
  /// The [status] is the new status for the agent.
  /// The optional [result] is set when the agent completes or errors.
  /// The optional [resumeId] is the SDK's short agent ID for resuming.
  void updateAgent(
    AgentStatus status,
    String sdkAgentId, {
    String? result,
    String? resumeId,
  }) {
    final agent = _activeAgents[sdkAgentId];
    if (agent != null) {
      _activeAgents[sdkAgentId] = agent.copyWith(
        status: status,
        result: result,
        resumeId: resumeId ?? agent.resumeId,
      );
      agents.notifyListeners();
    }
  }

  /// Finds an agent by its SDK resume ID.
  ///
  /// The [resumeId] is the short agent ID returned by the SDK (e.g., "adba350")
  /// that can be used with the Task tool's `resume` parameter.
  ///
  /// Returns null if no agent with that resume ID exists.
  Agent? findAgentByResumeId(String resumeId) {
    for (final agent in _activeAgents.values) {
      if (agent.resumeId == resumeId) {
        return agent;
      }
    }
    return null;
  }

  /// Adds an output entry to the primary conversation.
  ///
  /// Convenience method for adding entries to the main conversation.
  void addEntry(OutputEntry entry) {
    addOutputEntry(_data.primaryConversation.id, entry);
  }

  /// Adds an output entry to a conversation.
  ///
  /// The [conversationId] identifies which conversation to add to.
  /// The [entry] is the output entry to append.
  ///
  /// If persistence is initialized, the entry is also appended to the
  /// chat's JSONL file. Only primary conversation entries are persisted.
  void addOutputEntry(String conversationId, OutputEntry entry) {
    if (conversationId == _data.primaryConversation.id) {
      _data = _data.copyWith(
        primaryConversation: _data.primaryConversation.copyWith(
          entries: [..._data.primaryConversation.entries, entry],
        ),
      );
      // Skip persistence for streaming entries - they are persisted
      // when finalized by the assistant message handler.
      final isStreaming =
          (entry is TextOutputEntry && entry.isStreaming) ||
          (entry is ToolUseOutputEntry && entry.isStreaming);
      if (!isStreaming) {
        _persistEntry(entry);
      }
      // Track unread messages for assistant text output
      if (entry is TextOutputEntry && entry.contentType == 'text') {
        _incrementUnread();
      }
    } else {
      final conversation = _data.subagentConversations[conversationId];
      if (conversation != null) {
        _data = _data.copyWith(
          subagentConversations: {
            ..._data.subagentConversations,
            conversationId: conversation.copyWith(
              entries: [...conversation.entries, entry],
            ),
          },
        );
      }
    }
    conversations.notifyListeners();
  }

  // ---------------------------------------------------------------------------
  // Session Lifecycle Methods
  // ---------------------------------------------------------------------------

  /// Starts a new SDK session for this chat.
  ///
  /// Creates a session via [BackendService] and subscribes to event and
  /// permission request streams. The [eventHandler] consumes the typed
  /// events stream.
  ///
  /// If [lastSessionId] is set, attempts to resume that session instead of
  /// creating a fresh one. This allows conversations to continue across app
  /// restarts.
  ///
  /// Throws [StateError] if a session is already active.
  /// Throws [StateError] if the chat has no worktree root.
  Future<void> startSession({
    required BackendService backend,
    required EventHandler eventHandler,
    required String prompt,
    List<AttachedImage> images = const [],
    InternalToolsService? internalToolsService,
    String? systemPromptAppend,
  }) async {
    _t('Chat', '========== startSession ==========');
    _t('Chat', 'chatId: ${_data.id}');
    _t('Chat', 'chatName: ${_data.name}');
    _t('Chat', 'worktreeRoot: ${_data.worktreeRoot}');
    _t('Chat', 'model: ${model.id} (${model.backend.name})');
    _t(
      'Chat',
      'prompt: ${prompt.length > 80 ? '${prompt.substring(0, 80)}...' : prompt}',
    );
    _t('Chat', 'images: ${images.length}');
    _t('Chat', 'lastSessionId: $_lastSessionId');
    _t('Chat', 'backendReady: ${backend.isReady}');

    if (_agentRemoved) {
      throw StateError(
        _missingAgentMessage ?? 'Cannot start session: agent was removed',
      );
    }

    if (_transport != null || _session != null) {
      _t('Chat', 'ERROR: Session already active');
      throw StateError('Session already active');
    }

    final worktreeRoot = _data.worktreeRoot;
    if (worktreeRoot == null) {
      _t('Chat', 'ERROR: Chat has no worktree root');
      throw StateError('Chat has no worktree root');
    }

    if (_sessionPhase == SessionPhase.starting ||
        _sessionPhase == SessionPhase.stopping) {
      throw StateError('Session transition in progress: ${_sessionPhase.name}');
    }

    _sessionPhase = SessionPhase.starting;

    try {
      // Log if we're attempting to resume and add a session marker
      final isResumingSession = _lastSessionId != null;
      if (isResumingSession) {
        _t('Chat', 'Attempting to resume session: $_lastSessionId');
        developer.log(
          'Attempting to resume session: $_lastSessionId',
          name: 'Chat',
        );
      }

      // Build content blocks if images are attached
      List<sdk.ContentBlock>? content;
      if (images.isNotEmpty) {
        content = <sdk.ContentBlock>[
          if (prompt.trim().isNotEmpty) sdk.TextBlock(text: prompt),
          ...images.map(
            (img) => sdk.ImageBlock(
              source: sdk.ImageSource(
                type: 'base64',
                mediaType: img.mediaType,
                data: img.base64,
              ),
            ),
          ),
        ];
      }

      // Create transport with current settings, including resume if available
      _t('Chat', 'Calling backend.createTransport...');
      final sessionStopwatch = Stopwatch()..start();
      final sessionOptions = sdk.SessionOptions(
        model: model.id.isEmpty ? null : model.id,
        permissionMode: _securityConfig is sdk.ClaudeSecurityConfig
            ? (_securityConfig as sdk.ClaudeSecurityConfig).permissionMode
            : null,
        codexSecurityConfig: _securityConfig is sdk.CodexSecurityConfig
            ? _securityConfig as sdk.CodexSecurityConfig
            : null,
        resume: _lastSessionId,
        // Load permission rules and MCP servers from user, project, and local settings files
        settingSources: const ['user', 'project', 'local'],
        // Use Claude Code's system prompt (includes CLAUDE.md support)
        systemPrompt: sdk.PresetSystemPrompt(append: systemPromptAppend),
        // Stream partial messages if the setting is enabled
        includePartialMessages: RuntimeConfig.instance.streamOfThought,
      );

      _t('Chat', 'Using agent-keyed transport for agent $_agentId');
      _transport = await backend.createTransportForAgent(
        agentId: _agentId ?? RuntimeConfig.instance.defaultAgentId,
        prompt: prompt,
        cwd: worktreeRoot,
        options: sessionOptions,
        content: content,
        registry: internalToolsService?.registry,
      );

      _t(
        'Chat',
        'Transport created in ${sessionStopwatch.elapsedMilliseconds}ms',
      );

      // Capture capabilities from the transport (set during creation).
      _capabilities =
          _transport!.capabilities ?? const sdk.BackendCapabilities();

      // Sync server-reported model and reasoning effort to the UI.
      // These are available immediately from the transport (populated during
      // session creation) and won't arrive via the event stream because the
      // SessionInitEvent fires before we subscribe to events.
      _syncServerReportedValues(_transport!);

      _markStarted();

      // Set autocompact buffer based on backend type.
      // Claude uses a 22.5% buffer; Codex buffer is unknown.
      if (model.backend == sdk.BackendType.directCli) {
        _contextTracker.updateAutocompactBuffer(22.5);
      } else {
        _contextTracker.updateAutocompactBuffer(null);
      }

      // Store the event handler reference for permission response callbacks
      _eventHandler = eventHandler;
      _eventHandler?.beginSession(_data.id);

      // Store the new session ID for future resume.
      // Use resolvedSessionId which returns the SDK's session ID if available.
      final transport = _transport!;
      final newSessionId = transport.resolvedSessionId ?? transport.sessionId;
      if (newSessionId != null && newSessionId != _lastSessionId) {
        developer.log('Session created with ID: $newSessionId', name: 'Chat');
        _lastSessionId = newSessionId;
        // Persist the session ID to projects.json (fire-and-forget)
        _persistSessionId(newSessionId);
      }

      // Add a session resumed marker if we successfully resumed
      if (isResumingSession && newSessionId != null) {
        developer.log(
          'Session resumed successfully, adding marker',
          name: 'Chat',
        );
        addEntry(
          SessionMarkerEntry(
            timestamp: DateTime.now(),
            markerType: SessionMarkerType.resumed,
          ),
        );
      }

      // Subscribe to transport events stream for EventHandler
      _eventSubscription = _transport!.events.listen(
        (event) {
          eventHandler.handleEvent(_facade, event);
        },
        onError: (error) {
          _t('Chat', 'Event stream ERROR: $error');
          _handleError(error);
        },
        onDone: () {
          _t('Chat', 'Event stream DONE (chat=${_data.id})');
          _handleSessionEnd();
        },
      );

      // Subscribe to transport permission requests
      _t('Chat', 'Subscribing to permission requests...');
      _permissionSubscription = _transport!.permissionRequests.listen((req) {
        _t(
          'Chat',
          'Permission request: tool=${req.toolName} (chat=${_data.id})',
        );
        setPendingPermission(req);
      });

      // Mark as working since we're starting with a prompt
      _isWorking = true;
      _workingStopwatch = Stopwatch()..start();
      _sessionPhase = SessionPhase.active;

      _t('Chat', '========== Session fully set up, working=true ==========');
      session.notifyListeners();
    } catch (error) {
      _sessionPhase = SessionPhase.errored;
      await _teardownSession(
        clearSessionId: false,
        targetPhase: SessionPhase.idle,
      );
      rethrow;
    }
  }

  /// Sends a message to the active session.
  ///
  /// Adds a user input entry to the conversation and sends the message
  /// to the SDK session. Sets the working state to true.
  ///
  /// If [images] is provided and non-empty, the message is sent with
  /// content blocks including the images.
  ///
  /// Throws [StateError] if no session is active.
  Future<void> sendMessage(
    String text, {
    List<AttachedImage> images = const [],
    DisplayFormat displayFormat = DisplayFormat.plain,
  }) async {
    _t(
      'Chat',
      'sendMessage: ${text.length > 80 ? '${text.substring(0, 80)}...' : text} (chat=${_data.id}, images=${images.length})',
    );
    if (_sessionPhase == SessionPhase.starting ||
        _sessionPhase == SessionPhase.stopping ||
        _sessionPhase == SessionPhase.errored) {
      throw StateError(
        'Cannot send message while session phase is ${_sessionPhase.name}',
      );
    }
    if (_transport == null && _session == null) {
      _t('Chat', 'ERROR: sendMessage called with no active session');
      throw StateError('No active session');
    }

    // Add user message to conversation
    addEntry(
      UserInputEntry(
        timestamp: DateTime.now(),
        text: text,
        images: images,
        displayFormat: displayFormat,
      ),
    );

    // Mark as working
    setWorking(true);

    // Send via transport
    final sessionId = _transport?.sessionId ?? '';
    await _transport!.send(
      sdk.SendMessageCommand(sessionId: sessionId, text: text),
    );
  }

  /// Stops the current session.
  ///
  /// Cancels stream subscriptions, kills the session, and clears
  /// session-related state. Active agents are also cleared.
  Future<void> stopSession() async {
    _t(
      'Chat',
      'stopSession (chat=${_data.id}, hasSession=${_transport != null || _session != null})',
    );
    await _teardownSession(
      killActiveSession: true,
      clearSessionId: false,
      targetPhase: SessionPhase.ended,
    );

    _t('Chat', 'Session stopped');
  }

  /// Terminates this chat because its agent was removed from the registry.
  ///
  /// Kills any active session and sets the [agentRemoved] flag, which
  /// prevents new sessions from starting and disables the message input.
  /// The chat history is preserved and remains visible.
  Future<void> terminateForAgentRemoval() async {
    if (hasActiveSession) {
      await stopSession();
    }
    _agentRemoved = true;
    agents.notifyListeners();
    conversations.notifyListeners();
  }

  /// Interrupts the current session without killing it.
  ///
  /// This preserves the conversation context and allows Claude to continue
  /// after the interruption. Use this when the user wants to stop the current
  /// response but may want to continue the conversation.
  ///
  /// Does nothing if no session is active.
  Future<void> interrupt() async {
    // Check if we have an active session (either real or test)
    if (!hasActiveSession) return;

    developer.log('Interrupting session', name: 'Chat');

    // Interrupt via transport if available, fall back to direct session
    if (_transport != null) {
      final sessionId = _transport!.sessionId ?? '';
      await _transport!.send(sdk.InterruptCommand(sessionId: sessionId));
    } else if (_session != null) {
      await _session!.interrupt();
    }

    // Clear the working/compacting state - Claude will stop generating
    _isWorking = false;
    _isCompacting = false;
    _workingStopwatch?.stop();
    _workingStopwatch = null;
    _sessionPhase = hasActiveSession ? SessionPhase.active : SessionPhase.ended;

    // Update all active agents to error state since they were interrupted
    for (final sdkAgentId in _activeAgents.keys.toList()) {
      final agent = _activeAgents[sdkAgentId];
      if (agent != null && agent.status == AgentStatus.working) {
        _activeAgents[sdkAgentId] = agent.copyWith(
          status: AgentStatus.error,
          result: 'Interrupted by user',
        );
      }
    }

    session.notifyListeners();
    agents.notifyListeners();
  }

  /// Adds a permission request to the queue.
  ///
  /// Permission requests are processed in FIFO order. When multiple requests
  /// arrive concurrently, they are all queued and displayed to the user
  /// one at a time.
  ///
  /// Also sends a desktop notification to alert the user and records the
  /// timestamp for tracking user response time.
  ///
  /// When the first permission request arrives while working, the working
  /// stopwatch is paused so that user response time is not counted as
  /// Claude working time.
  void addPendingPermission(sdk.PermissionRequest request) {
    permissions.add(request);
  }

  /// @deprecated Use [addPendingPermission] instead.
  ///
  /// This method is kept for backwards compatibility but ignores null values.
  void setPendingPermission(sdk.PermissionRequest? request) {
    if (request != null) {
      permissions.add(request);
    }
  }

  /// Sets the working state.
  ///
  /// Called by [EventHandler] when starting/stopping work.
  /// When [working] is true, starts a new [Stopwatch] to track elapsed time.
  /// When [working] is false, reads elapsed time from the stopwatch, adds it
  /// to [_timingStats], and clears the stopwatch.
  ///
  /// Uses [Stopwatch] (monotonic clock) instead of wall-clock time so that
  /// system sleep/suspend is not counted as working time.
  void setWorking(bool working) {
    if (_isWorking != working) {
      // When transitioning from working to not working, record the elapsed time
      if (!working && _workingStopwatch != null) {
        _workingStopwatch!.stop();
        final elapsed = _workingStopwatch!.elapsed;
        metrics.addClaudeWorkingTime(elapsed);
      }

      _isWorking = working;
      if (working) {
        _workingStopwatch = Stopwatch()..start();
      } else {
        _workingStopwatch = null;
      }
      session.notifyListeners();
    }
  }

  /// Sets the compacting state.
  ///
  /// Called by [EventHandler] when receiving system status messages
  /// for context compaction. The UI can use [isCompacting] to show a
  /// different indicator during compaction.
  void setCompacting(bool compacting) {
    if (_isCompacting != compacting) {
      _isCompacting = compacting;
      session.notifyListeners();
    }
  }

  /// Responds to the current pending permission request with allow.
  ///
  /// If [updatedInput] is provided, it will be sent with the allow response.
  /// If [updatedPermissions] is provided, it will update the permission rules.
  ///
  /// After allowing, the next request in the queue (if any) becomes current.
  /// The user response time is recorded in [_timingStats].
  /// When the last permission is resolved, the working stopwatch is resumed.
  void allowPermission({
    Map<String, dynamic>? updatedInput,
    List<dynamic>? updatedPermissions,
  }) {
    permissions.allow(
      updatedInput: updatedInput,
      updatedPermissions: updatedPermissions,
    );
  }

  /// Syncs the local security config based on a permission response.
  ///
  /// Checks [updatedPermissions] for a `setMode` directive and updates
  /// accordingly. If the approved tool is `ExitPlanMode` with no explicit
  /// mode change, reverts to [PermissionMode.defaultMode] since plan mode
  /// has ended.
  ///
  /// Only applies to Claude chats.
  void _syncPermissionModeFromResponse(
    String? toolName,
    List<dynamic>? updatedPermissions,
  ) {
    // Only applies to Claude chats
    if (_securityConfig is! sdk.ClaudeSecurityConfig) return;

    // Check for explicit setMode in updatedPermissions
    if (updatedPermissions != null) {
      for (final perm in updatedPermissions) {
        if (perm is Map<String, dynamic> && perm['type'] == 'setMode') {
          final mode = perm['mode'] as String?;
          if (mode != null) {
            _securityConfig = sdk.ClaudeSecurityConfig(
              permissionMode: sdk.PermissionMode.fromString(mode),
            );
            _scheduleMetaSave();
            return;
          }
        }
      }
    }

    // ExitPlanMode approved without explicit setMode â†’ revert to default
    if (toolName == 'ExitPlanMode') {
      _securityConfig = const sdk.ClaudeSecurityConfig(
        permissionMode: sdk.PermissionMode.defaultMode,
      );
      _scheduleMetaSave();
    }
  }

  /// Responds to the current pending permission request with deny.
  ///
  /// The [message] explains why the permission was denied.
  /// If [interrupt] is true, the session will be interrupted.
  ///
  /// After denying, the next request in the queue (if any) becomes current.
  /// The user response time is recorded in [_timingStats].
  /// When the last permission is resolved, the working stopwatch is resumed.
  void denyPermission(String message, {bool interrupt = false}) {
    permissions.deny(message, interrupt: interrupt);
  }

  /// Removes a pending permission request by tool use ID.
  ///
  /// This handles the timeout case: when the SDK times out waiting for
  /// permission, it sends a tool result (denied), and we should dismiss
  /// the stale permission widget.
  ///
  /// This is safe for parallel tool calls because we match by toolUseId,
  /// so only the specific tool's permission is cleared, not others.
  ///
  /// Note: This does NOT record user response time since the permission
  /// was timed out, not responded to by the user.
  /// When the last permission is removed, the working stopwatch is resumed.
  void removePendingPermissionByToolUseId(String toolUseId) {
    permissions.removeByToolUseId(toolUseId);
  }

  Future<void> _teardownSession({
    bool killActiveSession = false,
    required bool clearSessionId,
    required SessionPhase targetPhase,
  }) {
    final inFlight = _teardownInFlight;
    if (inFlight != null) {
      return inFlight;
    }

    _sessionPhase = SessionPhase.stopping;

    final permissionSubscription = _permissionSubscription;
    final eventSubscription = _eventSubscription;
    final transport = _transport;
    final agentSession = _session;

    _clearEventHandlerState();
    _eventHandler = null;
    _eventSubscription = null;
    _permissionSubscription = null;
    _transport = null;
    _session = null;
    _testHasActiveSession = false;
    permissions._clearInternal();
    _activeAgents.clear();
    _clearAcpSessionMetadata();
    _isWorking = false;
    _isCompacting = false;
    _workingStopwatch?.stop();
    _workingStopwatch = null;

    if (clearSessionId) {
      _lastSessionId = null;
      _persistSessionId(null);
    }

    _sessionPhase = targetPhase;
    this.session.notifyListeners();
    permissions.notifyListeners();
    agents.notifyListeners();
    settings.notifyListeners();

    final teardown = () async {
      await permissionSubscription?.cancel();
      await eventSubscription?.cancel();

      if (killActiveSession) {
        if (transport != null) {
          final sessionId = transport.sessionId ?? '';
          try {
            await transport.send(sdk.KillCommand(sessionId: sessionId));
          } catch (_) {
            // Teardown continues even if kill command fails.
          }
          await transport.dispose();
        } else {
          await agentSession?.kill();
        }
      } else {
        await transport?.dispose();
      }
    }();

    _teardownInFlight = teardown.whenComplete(() {
      _teardownInFlight = null;
    });

    return _teardownInFlight!;
  }

  /// Handles errors from the session message stream.
  void _handleError(Object error) {
    _t('Chat', '_handleError: $error (chat=${_data.id})');
    developer.log('Session error: $error', name: 'Chat', error: error);

    // Add error entry to conversation
    addEntry(
      TextOutputEntry(
        timestamp: DateTime.now(),
        text: 'Error: $error',
        contentType: 'error',
      ),
    );

    // Clear session ID on error - the session may be in an invalid state
    // and cannot be resumed
    unawaited(
      _teardownSession(clearSessionId: true, targetPhase: SessionPhase.errored),
    );
  }

  /// Handles session end (when the message stream closes).
  void _handleSessionEnd() {
    _t('Chat', '_handleSessionEnd (chat=${_data.id}, isWorking=$_isWorking)');
    developer.log('Session ended', name: 'Chat');

    unawaited(
      _teardownSession(clearSessionId: false, targetPhase: SessionPhase.ended),
    );
  }

  /// Sets the SDK session for this chat.
  ///
  /// This is a low-level method for testing. Prefer [startSession] for
  /// creating sessions in production code.
  @visibleForTesting
  void setSession(sdk.AgentSession? session) {
    _session = session;
    if (session != null) {
      _sessionPhase = SessionPhase.active;
    } else if (!hasActiveSession) {
      _sessionPhase = SessionPhase.idle;
    }
    this.session.notifyListeners();
  }

  /// Sets the transport for this chat.
  ///
  /// This is a low-level method for testing. Prefer [startSession] for
  /// creating sessions in production code.
  @visibleForTesting
  void setTransport(sdk.EventTransport? transport) {
    _transport = transport;
    if (transport != null) {
      _sessionPhase = SessionPhase.active;
    } else if (!hasActiveSession) {
      _sessionPhase = SessionPhase.idle;
    }
    session.notifyListeners();
  }

  /// Marks the chat as having an active session for testing purposes.
  ///
  /// This is used in tests where we need to simulate an active session
  /// without having an actual [AgentSession] instance.
  @visibleForTesting
  void setHasActiveSessionForTesting(bool hasSession) {
    if (hasSession) {
      // For testing hasActiveSession we use a sentinel approach with a
      // test-only field rather than creating a real session.
      _testHasActiveSession = true;
      _sessionPhase = SessionPhase.active;
    } else {
      _testHasActiveSession = false;
      _session = null;
      if (_transport == null) {
        _sessionPhase = SessionPhase.idle;
      }
    }
    session.notifyListeners();
  }

  /// Test-only flag to override hasActiveSession.
  ///
  /// When true, hasActiveSession returns true even if _session is null.
  /// This is only for testing purposes.
  // ignore: invalid_visibility_annotation
  bool _testHasActiveSession = false;

  /// Clears the SDK session and active agents.
  ///
  /// Call this when the session ends (e.g., after `/clear` command).
  /// Agents are discarded but conversations persist.
  void clearSession() {
    unawaited(
      _teardownSession(clearSessionId: false, targetPhase: SessionPhase.ended),
    );
  }

  /// Resets the session completely for the /clear command.
  ///
  /// Stops the current session, clears the session ID so the next
  /// session starts fresh (no resume), resets the context tracker,
  /// and adds a [ContextClearedEntry] marker to the conversation.
  Future<void> resetSession() async {
    await stopSession();
    _lastSessionId = null;
    _persistSessionId(null);
    resetContext();
    addEntry(ContextClearedEntry(timestamp: DateTime.now()));
    session.notifyListeners();
    metrics.notifyListeners();
    conversations.notifyListeners();
  }

  /// Clears all entries from the primary conversation.
  ///
  /// Useful for testing/replay scenarios where we want to reset state.
  void clearEntries() {
    _data = _data.copyWith(
      primaryConversation: _data.primaryConversation.copyWith(
        entries: const [],
      ),
    );
    conversations.notifyListeners();
  }

  /// Loads entries from persistence without triggering persistence writes.
  ///
  /// This is used when restoring chat history from disk. The entries are
  /// already persisted, so we don't want to re-write them.
  ///
  /// Replaces any existing entries in the primary conversation.
  void loadEntriesFromPersistence(List<OutputEntry> entries) {
    if (entries.isNotEmpty) {
      _markStarted();
    }
    _data = _data.copyWith(
      primaryConversation: _data.primaryConversation.copyWith(
        entries: List.unmodifiable(entries),
      ),
    );
    _historyLoaded = true;
    conversations.notifyListeners();
  }

  /// Marks chat history as loaded even when there are no entries.
  ///
  /// Used by [ProjectRestoreService] when the JSONL file is empty or doesn't exist.
  void markHistoryAsLoaded() {
    _historyLoaded = true;
  }

  /// Whether the chat history has been loaded from persistence.
  ///
  /// Used to determine if lazy-loading is needed when a chat is selected.
  /// Uses a dedicated flag rather than entry count because security config
  /// changes during restore can add notification entries.
  bool get hasLoadedHistory => _historyLoaded;

  // ---------------------------------------------------------------------------
  // Context and Usage Tracking Methods
  // ---------------------------------------------------------------------------

  /// Updates context tracking from an assistant message's usage data.
  void updateContextFromUsage(Map<String, dynamic> usage) {
    metrics.updateContextFromUsage(usage);
  }

  /// Accumulates output tokens from a single API step during a turn.
  ///
  /// Called by [EventHandler] for each [UsageUpdateEvent] (both main agent
  /// and subagents). This allows the cost indicator to show running token
  /// totals mid-turn. The accumulator is reset when [updateCumulativeUsage]
  /// applies the authoritative totals from the result message.
  void addInTurnOutputTokens(int outputTokens) {
    metrics.addInTurnOutputTokens(outputTokens);
  }

  /// Updates usage from a result message.
  ///
  /// The SDK provides session-cumulative values in `modelUsage` and
  /// `total_cost_usd`. We add the base offset from previous sessions
  /// to get the chat-wide total.
  ///
  /// For multi-session chats (e.g., after resume), [_baseUsage] and
  /// [_baseModelUsage] contain the totals from previous sessions.
  void updateCumulativeUsage({
    required UsageInfo usage,
    required double totalCostUsd,
    List<ModelUsageInfo>? modelUsage,
    int? contextWindow,
  }) {
    metrics.updateCumulativeUsage(
      usage: usage,
      totalCostUsd: totalCostUsd,
      modelUsage: modelUsage,
      contextWindow: contextWindow,
    );
  }

  /// Resets context tracker (e.g., after /clear command).
  void resetContext() {
    metrics.resetContext();
  }

  /// Restores context and usage from persisted ChatMeta.
  ///
  /// Called by ProjectRestoreService when loading a chat.
  /// Sets up base usage for resume support - when a new session starts,
  /// the base values are added to the session's cumulative values.
  void restoreFromMeta(
    ContextInfo context,
    UsageInfo usage, {
    List<ModelUsageInfo> modelUsage = const [],
    TimingStats timing = const TimingStats.zero(),
  }) {
    metrics.restoreFromMeta(
      context,
      usage,
      modelUsage: modelUsage,
      timing: timing,
    );
  }

  // ---------------------------------------------------------------------------
  // Persistence Methods
  // ---------------------------------------------------------------------------

  /// Persists an entry to the chat's JSONL file.
  ///
  /// Does nothing if persistence is not initialized.
  /// Errors are logged but do not throw to avoid breaking the UI.
  Future<void> _persistEntry(OutputEntry entry) async {
    await persistence.persistEntry(entry);
  }

  /// Persists a streaming entry that has been finalized.
  ///
  /// Called by [EventHandler] when the complete
  /// assistant message arrives and finalizes a previously streaming entry.
  /// Only persists entries belonging to the primary conversation.
  void persistStreamingEntry(OutputEntry entry) {
    persistence.persistStreamingEntry(entry);
  }

  /// Persists a tool result to the chat's JSONL file.
  ///
  /// This is called by [EventHandler] when a tool result arrives.
  /// The result is stored as a separate [ToolResultEntry] which will be
  /// merged with the corresponding [ToolUseOutputEntry] when the history
  /// is loaded.
  ///
  /// Does nothing if persistence is not initialized.
  void persistToolResult(String toolUseId, dynamic result, bool isError) {
    persistence.persistToolResult(toolUseId, result, isError);
  }

  /// Schedules a debounced save of the chat metadata.
  ///
  /// Cancels any pending save and schedules a new one for 1 second later.
  /// This prevents excessive file writes when settings change rapidly.
  void _scheduleMetaSave() {
    persistence.scheduleMetaSave();
  }

  void _markStarted() {
    persistence.markStarted();
  }

  /// Saves the chat metadata to disk.
  ///
  /// Creates a [ChatMeta] from the current state and persists it.
  /// Errors are logged but do not throw to avoid breaking the UI.
  Future<void> _saveMeta() async {
    await persistence.saveMeta();
  }

  String get _backendTypeValue {
    return switch (_model.backend) {
      sdk.BackendType.codex => 'codex',
      sdk.BackendType.acp => 'acp',
      sdk.BackendType.directCli => 'claude',
    };
  }

  /// User-facing backend label for cost tracking.
  ///
  /// When an agent ID is set, returns the agent name from the registry.
  /// Otherwise falls back to driver-based labels: 'claude', 'codex', 'acp'.
  String get backendLabel {
    final id = _agentId;
    if (id != null) {
      final config = RuntimeConfig.instance.agentById(id);
      if (config != null) return config.name.toLowerCase();
    }
    return switch (_model.backend) {
      sdk.BackendType.codex => 'codex',
      sdk.BackendType.acp => 'acp',
      sdk.BackendType.directCli => 'claude',
    };
  }

  /// Persists the session ID to projects.json.
  ///
  /// This is a fire-and-forget operation - errors are logged but don't block
  /// the UI. The session ID is stored in the ChatReference within projects.json
  /// to enable session resume across app restarts.
  ///
  /// Does nothing if persistence is not properly initialized (missing projectRoot
  /// or worktreePath).
  void _persistSessionId(String? sessionId) {
    persistence.persistSessionId(sessionId);
  }

  @override
  void dispose() {
    persistence.dispose();
    // Cancel stream subscriptions.
    _permissionSubscription?.cancel();
    _eventSubscription?.cancel();
    // Dispose the transport (which handles session cleanup).
    _transport?.dispose();
    _transport = null;
    // Kill the session if active (fallback for test sessions without transport).
    _session?.kill();
    _session = null;
    _testHasActiveSession = false;
    _clearEventHandlerState();
    _eventHandler = null;
    _eventSubscription = null;
    _permissionSubscription = null;
    permissions._clearInternal();
    _activeAgents.clear();
    _sessionPhase = SessionPhase.ended;
    session.dispose();
    permissions.dispose();
    settings.dispose();
    metrics.dispose();
    agents.dispose();
    conversations.dispose();
    viewState.dispose();
    // Dispose the context tracker.
    _contextTracker.dispose();
    super.dispose();
  }
}
