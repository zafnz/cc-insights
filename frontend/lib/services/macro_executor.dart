import 'dart:developer' as developer;

import 'package:claude_sdk/claude_sdk.dart' as sdk;
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../models/agent_config.dart';
import '../models/chat.dart';
import '../models/chat_model.dart';
import '../models/output_entry.dart';
import '../models/project.dart';
import '../models/user_action.dart';
import '../models/worktree.dart';
import '../state/selection_state.dart';
import '../widgets/insights_widgets.dart';
import 'backend_service.dart';
import 'event_handler.dart';
import 'internal_tools_service.dart';
import 'project_restore_service.dart';
import 'runtime_config.dart';

/// Executes app-internal macro actions from the Actions panel.
class MacroExecutor {
  /// Runs a start-chat macro.
  ///
  /// Creates a new chat in [worktree], selects it, sends [macro.instruction],
  /// and starts a backend session automatically.
  static Future<void> executeStartChat(
    BuildContext context,
    WorktreeState worktree,
    StartChatMacro macro,
  ) async {
    final instruction = macro.instruction.trim();
    if (instruction.isEmpty) return;

    final agent = _resolveAgent(macro.agentId);
    if (agent == null) {
      showErrorSnackBar(
        context,
        'Agent "${macro.agentId}" was not found. Update this macro in Project Settings.',
      );
      return;
    }

    final backendService = context.read<BackendService>();
    await backendService.startAgent(agent.id, config: agent);
    final error = backendService.errorForAgent(agent.id);
    if (error != null) {
      if (context.mounted && !backendService.isAgentErrorForAgent(agent.id)) {
        showErrorSnackBar(context, error);
      }
      return;
    }

    final preferredModel = macro.model?.trim().isNotEmpty == true
        ? macro.model!.trim()
        : (agent.defaultModel.trim().isNotEmpty ? agent.defaultModel : null);

    final model = ChatModelCatalog.defaultForBackend(
      agent.backendType,
      preferredModel,
    );

    await createChatAndSendMessage(
      context,
      worktree: worktree,
      text: instruction,
      agentId: agent.id,
      model: model,
      securityConfig: _securityFromAgent(agent),
      clearWelcomeDraft: false,
    );
  }

  /// Creates a new chat in [worktree], selects it, appends the user message,
  /// and starts the first session turn.
  ///
  /// Used by the welcome screen and start-chat macros.
  static Future<void> createChatAndSendMessage(
    BuildContext context, {
    required WorktreeState? worktree,
    required String text,
    List<AttachedImage> images = const [],
    DisplayFormat displayFormat = DisplayFormat.plain,
    String? agentId,
    ChatModel? model,
    sdk.SecurityConfig? securityConfig,
    sdk.ReasoningEffort? reasoningEffort,
    bool clearWelcomeDraft = false,
  }) async {
    if (text.trim().isEmpty && images.isEmpty) return;
    if (worktree == null) return;

    final selection = context.read<SelectionState>();
    final project = context.read<ProjectState>();
    final backend = context.read<BackendService>();
    final eventHandler = context.read<EventHandler>();
    final internalTools = context.read<InternalToolsService>();
    final restoreService = context.read<ProjectRestoreService>();

    final aiLabelsEnabled = RuntimeConfig.instance.aiChatLabelsEnabled;
    final String chatName;
    final bool isAutoGenerated;
    if (aiLabelsEnabled) {
      chatName = _generateChatName(text);
      isAutoGenerated = true;
    } else {
      chatName = 'Chat #${worktree.chats.length + 1}';
      isAutoGenerated = false;
    }

    final chat = ChatState.create(
      name: chatName,
      worktreeRoot: worktree.data.worktreeRoot,
      isAutoGeneratedName: isAutoGenerated,
      agentId: agentId ?? worktree.welcomeAgentId,
    );

    chat.setModel(model ?? worktree.welcomeModel);
    chat.setSecurityConfig(securityConfig ?? worktree.welcomeSecurityConfig);
    chat.setReasoningEffort(reasoningEffort ?? worktree.welcomeReasoningEffort);

    if (clearWelcomeDraft) {
      worktree.welcomeDraftText = '';
    }

    worktree.addChat(chat, select: true);
    selection.selectChat(chat);

    restoreService
        .addChatToWorktree(
          project.data.repoRoot,
          worktree.data.worktreeRoot,
          chat,
        )
        .catchError((error) {
          developer.log(
            'Failed to persist chat: $error',
            name: 'MacroExecutor',
            level: 900,
          );
        });

    chat.addEntry(
      UserInputEntry(
        timestamp: DateTime.now(),
        text: text,
        images: images,
        displayFormat: displayFormat,
      ),
    );

    eventHandler.generateChatTitle(chat, text);

    try {
      await chat.startSession(
        backend: backend,
        eventHandler: eventHandler,
        prompt: text,
        images: images,
        internalToolsService: internalTools,
      );
    } catch (e) {
      chat.addEntry(
        TextOutputEntry(
          timestamp: DateTime.now(),
          text: 'Failed to start session: $e',
          contentType: 'error',
        ),
      );
    }
  }

  static AgentConfig? _resolveAgent(String agentId) {
    final fromRuntime = RuntimeConfig.instance.agentById(agentId);
    if (fromRuntime != null) return fromRuntime;
    for (final agent in AgentConfig.defaults) {
      if (agent.id == agentId) return agent;
    }
    return null;
  }

  static sdk.SecurityConfig _securityFromAgent(AgentConfig agent) {
    if (agent.driver == 'codex') {
      return sdk.CodexSecurityConfig(
        sandboxMode: sdk.CodexSandboxMode.fromNameOrWire(
          agent.codexSandboxMode ?? 'workspace-write',
        ),
        approvalPolicy: sdk.CodexApprovalPolicy.fromNameOrWire(
          agent.codexApprovalPolicy ?? 'on-request',
        ),
      );
    }
    return sdk.ClaudeSecurityConfig(
      permissionMode: sdk.PermissionMode.fromString(
        agent.defaultPermissions.isEmpty ? 'default' : agent.defaultPermissions,
      ),
    );
  }

  static String _generateChatName(String message) {
    final trimmed = message.trim();
    if (trimmed.length <= 30) return trimmed;

    final truncated = trimmed.substring(0, 30);
    final lastSpace = truncated.lastIndexOf(' ');
    if (lastSpace > 15) {
      return '${truncated.substring(0, lastSpace)}...';
    }
    return '$truncated...';
  }
}
