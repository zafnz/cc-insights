import 'dart:io';

import 'package:path/path.dart' as p;

/// Result of checking the app's installation location.
class LocationCheck {
  final bool isSane;
  final String appPath;
  final String? reason;
  final bool isAppBundle;

  const LocationCheck({
    required this.isSane,
    required this.appPath,
    this.reason,
    this.isAppBundle = true,
  });
}

/// Utility service for installing a CLI launcher script at ~/.local/bin/cc-insights.
///
/// The launcher script directly `exec`s the app binary inside the .app bundle,
/// matching the pattern used by the Homebrew wrapper.
class CliLauncherService {
  /// Target path for the CLI launcher script (relative to home).
  static const _launcherRelativePath = '.local/bin/cc-insights';

  /// Returns the full path to the launcher script (~/.local/bin/cc-insights).
  static String get launcherPath {
    final home = Platform.environment['HOME'] ?? '';
    return p.join(home, _launcherRelativePath);
  }

  /// Returns the resolved executable path (the actual binary inside the bundle).
  static String get executablePath => Platform.resolvedExecutable;

  /// Resolves the .app bundle path from [Platform.resolvedExecutable].
  ///
  /// Walks up from a path like:
  ///   /Applications/CC Insights.app/Contents/MacOS/CC Insights
  /// to find the `.app` directory.
  /// Returns null if not running from a .app bundle.
  static String? resolveAppBundlePath([String? fromPath]) {
    var current = fromPath ?? Platform.resolvedExecutable;
    while (current != '/' && current.isNotEmpty) {
      if (p.basename(current).endsWith('.app')) return current;
      current = p.dirname(current);
    }
    return null;
  }

  /// Checks if the app is running from a sane installation location.
  static LocationCheck checkAppLocation([String? fromPath]) {
    final appPath = resolveAppBundlePath(fromPath);
    if (appPath == null) {
      return LocationCheck(
        isSane: false,
        appPath: fromPath ?? Platform.resolvedExecutable,
        reason: 'Not running from a macOS app bundle.',
        isAppBundle: false,
      );
    }

    final home = Platform.environment['HOME'] ?? '';

    // Bad locations
    if (appPath.startsWith('$home/Downloads')) {
      return LocationCheck(
        isSane: false,
        appPath: appPath,
        reason:
            'CC Insights is running from your Downloads folder. '
            'Move it to /Applications first, then try again.',
        isAppBundle: true,
      );
    }
    if (appPath.startsWith('/Volumes/')) {
      return LocationCheck(
        isSane: false,
        appPath: appPath,
        reason:
            'CC Insights is running from a disk image. '
            'Drag it to /Applications first, then try again.',
        isAppBundle: true,
      );
    }
    if (appPath.startsWith('/tmp') || appPath.startsWith('/private/tmp')) {
      return LocationCheck(
        isSane: false,
        appPath: appPath,
        reason:
            'CC Insights is running from a temporary directory. '
            'Move it to /Applications first, then try again.',
        isAppBundle: true,
      );
    }

    // Good or neutral location
    return LocationCheck(isSane: true, appPath: appPath, isAppBundle: true);
  }

  /// Whether the launcher script already exists at ~/.local/bin/cc-insights.
  static bool isInstalled() => File(launcherPath).existsSync();

  /// Generates the launcher script content.
  static String generateScript(String execPath) {
    return '#!/bin/bash\n'
        '# CC Insights CLI launcher\n'
        '# Generated by CC Insights - do not edit\n'
        'exec "$execPath" "\$@"\n';
  }

  /// Installs the CLI launcher script.
  ///
  /// Creates ~/.local/bin/ if needed, writes the script, and makes it
  /// executable. Returns null on success, or an error message on failure.
  static Future<String?> install([String? execPath]) async {
    final path = execPath ?? Platform.resolvedExecutable;

    try {
      final file = File(launcherPath);
      final dir = file.parent;

      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }

      await file.writeAsString(generateScript(path));
      await Process.run('chmod', ['+x', launcherPath]);

      return null; // success
    } catch (e) {
      return 'Failed to install CLI launcher: $e';
    }
  }

  /// Checks whether `cc-insights` is resolvable from the user's login shell.
  ///
  /// The GUI app's process PATH is the minimal macOS default and almost never
  /// includes `~/.local/bin`, so we spawn a login shell and use `command -v`
  /// to get an accurate answer.
  static Future<bool> isCommandInPath() async {
    try {
      final shell = Platform.environment['SHELL'] ?? '/bin/zsh';
      final result = await Process.run(
        shell,
        ['-l', '-c', 'command -v cc-insights'],
      );
      return result.exitCode == 0 &&
          (result.stdout as String).trim().isNotEmpty;
    } catch (_) {
      return false;
    }
  }

  static const _pathExportLine =
      'export PATH="\$HOME/.local/bin:\$PATH"';
  static const _pathComment = '# Added by CC Insights';

  /// Appends a PATH export line to ~/.zshrc so that ~/.local/bin is in PATH.
  ///
  /// Idempotent â€” skips if the export line already exists.
  /// [rcPath] can be overridden for testing.
  /// Returns null on success, or an error message on failure.
  static Future<String?> addToPath([String? rcPath]) async {
    try {
      final home = Platform.environment['HOME'] ?? '';
      final file = File(rcPath ?? p.join(home, '.zshrc'));

      // Read existing content (create file if it doesn't exist)
      final contents = await file.exists() ? await file.readAsString() : '';

      // Check if already present
      if (contents.contains('.local/bin')) {
        return null; // already configured
      }

      // Append with a newline guard
      final prefix = contents.isEmpty || contents.endsWith('\n') ? '' : '\n';
      await file.writeAsString(
        '$prefix\n$_pathComment\n$_pathExportLine\n',
        mode: FileMode.append,
      );

      return null; // success
    } catch (e) {
      return 'Failed to update ~/.zshrc: $e';
    }
  }
}
