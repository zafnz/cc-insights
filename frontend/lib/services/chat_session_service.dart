import 'dart:developer' as developer;

import '../models/chat.dart';
import '../models/output_entry.dart';
import 'backend_service.dart';
import 'event_handler.dart';
import 'internal_tools_service.dart';

/// Service for managing chat session lifecycle operations.
///
/// Encapsulates the business logic of starting sessions, sending messages,
/// handling interrupts, and plan approval workflows. Widgets call these
/// methods instead of directly orchestrating BackendService/EventHandler.
class ChatSessionService {
  final BackendService _backend;
  final EventHandler _eventHandler;
  final InternalToolsService _internalTools;

  ChatSessionService({
    required BackendService backend,
    required EventHandler eventHandler,
    required InternalToolsService internalTools,
  })  : _backend = backend,
        _eventHandler = eventHandler,
        _internalTools = internalTools;

  /// Submits a message to a chat, creating a session if needed.
  ///
  /// Handles `/clear` command by resetting the session.
  /// For new sessions, adds a [UserInputEntry] and generates a chat title
  /// if the name is auto-generated. For existing sessions, sends the message
  /// directly.
  Future<void> submitMessage(
    ChatState chat, {
    required String text,
    List<AttachedImage> images = const [],
    DisplayFormat displayFormat = DisplayFormat.plain,
  }) async {
    if (text.trim().isEmpty && images.isEmpty) return;

    // Handle /clear command - reset session without sending to SDK
    if (text.trim() == '/clear') {
      chat.draftText = '';
      await chat.resetSession();
      return;
    }

    // Clear the draft text since it's being submitted
    chat.draftText = '';

    if (!chat.hasActiveSession) {
      // First message - start a new session with the prompt
      chat.addEntry(UserInputEntry(
        timestamp: DateTime.now(),
        text: text,
        images: images,
        displayFormat: displayFormat,
      ));

      // Generate a better title for the chat if it's new (fire-and-forget)
      if (chat.isAutoGeneratedName) {
        _eventHandler.generateChatTitle(chat, text);
      }

      try {
        await chat.startSession(
          backend: _backend,
          eventHandler: _eventHandler,
          prompt: text,
          images: images,
          internalToolsService: _internalTools,
        );
      } catch (e) {
        chat.addEntry(TextOutputEntry(
          timestamp: DateTime.now(),
          text: 'Failed to start session: $e',
          contentType: 'error',
        ));
      }
    } else {
      // Subsequent message - send to existing session
      try {
        await chat.sendMessage(
          text,
          images: images,
          displayFormat: displayFormat,
        );
      } catch (e) {
        chat.addEntry(TextOutputEntry(
          timestamp: DateTime.now(),
          text: 'Failed to send message: $e',
          contentType: 'error',
        ));
      }
    }
  }

  /// Interrupts the active session on a chat.
  Future<void> interrupt(ChatState chat) async {
    try {
      await chat.interrupt();
    } catch (e) {
      developer.log(
        'Failed to interrupt session: $e',
        name: 'ChatSessionService',
        error: e,
      );
    }
  }

  /// Handles the "clear context + plan approval" workflow.
  ///
  /// 1. Allows the ExitPlanMode permission (so CLI gets a response)
  /// 2. Resets the session (clears context)
  /// 3. Switches to acceptEdits mode
  /// 4. Starts a new session with the plan text as the prompt
  Future<void> approvePlanWithClearContext(
    ChatState chat,
    String planText,
  ) async {
    // 1. Allow the ExitPlanMode permission first
    chat.allowPermission(
      updatedPermissions: [
        {
          'type': 'setMode',
          'mode': 'acceptEdits',
          'destination': 'session',
        },
      ],
    );

    // 2. Reset session (clears context, stops session)
    await chat.resetSession();

    // 3. Switch to acceptEdits mode for the new session
    chat.setPermissionMode(PermissionMode.acceptEdits);

    // 4. Start new session with plan as prompt
    final prompt =
        'The user has approved your plan and wants you to execute it '
        'with a clear context. Here is the approved plan:\n\n'
        '$planText\n\n'
        'Begin implementation.';

    chat.addEntry(UserInputEntry(
      timestamp: DateTime.now(),
      text: '[Plan approved - clear context + accept edits]',
    ));

    try {
      await chat.startSession(
        backend: _backend,
        eventHandler: _eventHandler,
        prompt: prompt,
        internalToolsService: _internalTools,
      );
    } catch (e) {
      chat.addEntry(TextOutputEntry(
        timestamp: DateTime.now(),
        text: 'Failed to start session: $e',
        contentType: 'error',
      ));
    }
  }

  /// Starts a session on the given chat with the specified prompt.
  ///
  /// If [showInConversation] is true (default), adds a [UserInputEntry]
  /// before starting the session. Set to false for hidden prompts
  /// (e.g. conflict resolution preambles).
  Future<void> startSession(
    ChatState chat, {
    required String prompt,
    List<AttachedImage> images = const [],
    bool showInConversation = true,
    DisplayFormat displayFormat = DisplayFormat.plain,
    String? systemPromptAppend,
  }) async {
    if (showInConversation) {
      chat.addEntry(UserInputEntry(
        timestamp: DateTime.now(),
        text: prompt,
        images: images,
        displayFormat: displayFormat,
      ));
    }

    try {
      await chat.startSession(
        backend: _backend,
        eventHandler: _eventHandler,
        prompt: prompt,
        images: images,
        internalToolsService: _internalTools,
        systemPromptAppend: systemPromptAppend,
      );
    } catch (e) {
      chat.addEntry(TextOutputEntry(
        timestamp: DateTime.now(),
        text: 'Failed to start session: $e',
        contentType: 'error',
      ));
    }
  }
}
