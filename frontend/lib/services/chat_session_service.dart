import 'dart:developer' as developer;

import '../models/chat.dart';
import '../models/output_entry.dart';
import 'backend_service.dart';
import 'chat_title_service.dart';
import 'event_handler.dart';
import 'internal_tools_service.dart';

/// Service for managing chat session lifecycle operations.
///
/// Encapsulates the business logic of starting sessions, sending messages,
/// handling interrupts, and plan approval workflows. Widgets call these
/// methods instead of directly orchestrating BackendService/EventHandler.
class ChatSessionService {
  final BackendService _backend;
  final EventHandler _eventHandler;
  final InternalToolsService _internalTools;
  final ChatTitleService _chatTitleService;

  ChatSessionService({
    required BackendService backend,
    required EventHandler eventHandler,
    required InternalToolsService internalTools,
    required ChatTitleService chatTitleService,
  }) : _backend = backend,
       _eventHandler = eventHandler,
       _internalTools = internalTools,
       _chatTitleService = chatTitleService;

  /// Submits a message to a chat, creating a session if needed.
  ///
  /// Handles `/clear` command by resetting the session.
  /// For new sessions, adds a [UserInputEntry] and generates a chat title
  /// if the name is auto-generated. For existing sessions, sends the message
  /// directly.
  Future<void> submitMessage(
    Chat chat, {
    required String text,
    List<AttachedImage> images = const [],
    DisplayFormat displayFormat = DisplayFormat.plain,
  }) async {
    if (text.trim().isEmpty && images.isEmpty) return;

    // Handle /clear command - reset session without sending to SDK
    if (text.trim() == '/clear') {
      chat.viewState.draftText = '';
      await chat.session.reset();
      return;
    }

    // Clear the draft text since it's being submitted
    chat.viewState.draftText = '';

    if (!chat.session.hasActiveSession) {
      // First message - start a new session with the prompt
      chat.conversations.addEntry(
        UserInputEntry(
          timestamp: DateTime.now(),
          text: text,
          images: images,
          displayFormat: displayFormat,
        ),
      );

      // Generate a better title for the chat if it's new (fire-and-forget)
      if (chat.data.isAutoGeneratedName) {
        _chatTitleService.generateChatTitle(chat, text);
      }

      try {
        await chat.session.start(
          backend: _backend,
          eventHandler: _eventHandler,
          prompt: text,
          images: images,
          internalToolsService: _internalTools,
        );
      } catch (e) {
        chat.conversations.addEntry(
          TextOutputEntry(
            timestamp: DateTime.now(),
            text: 'Failed to start session: $e',
            contentType: 'error',
          ),
        );
      }
    } else {
      // Subsequent message - send to existing session
      try {
        await chat.session.sendMessage(
          text,
          images: images,
          displayFormat: displayFormat,
        );
      } catch (e) {
        chat.conversations.addEntry(
          TextOutputEntry(
            timestamp: DateTime.now(),
            text: 'Failed to send message: $e',
            contentType: 'error',
          ),
        );
      }
    }
  }

  /// Interrupts the active session on a chat.
  Future<void> interrupt(Chat chat) async {
    try {
      await chat.session.interrupt();
    } catch (e) {
      developer.log(
        'Failed to interrupt session: $e',
        name: 'ChatSessionService',
        error: e,
      );
    }
  }

  /// Allows the currently pending permission request for a chat.
  ///
  /// Orchestrates cross-substate effects (permission-mode sync and session UI
  /// refresh) outside of [ChatPermissionState].
  void allowPermission(
    Chat chat, {
    Map<String, dynamic>? updatedInput,
    List<dynamic>? updatedPermissions,
  }) {
    final toolName = chat.permissions.pendingPermission?.toolName;
    final shouldSyncMode =
        updatedPermissions != null || toolName == 'ExitPlanMode';
    if (shouldSyncMode) {
      chat.settings.syncPermissionModeFromResponse(
        toolName,
        updatedPermissions,
      );
    }
    chat.permissions.allow(
      updatedInput: updatedInput,
      updatedPermissions: updatedPermissions,
    );
    chat.session.notifyPermissionQueueChanged();
  }

  /// Denies the currently pending permission request for a chat.
  ///
  /// Orchestrates cross-substate effects outside of [ChatPermissionState].
  void denyPermission(Chat chat, String message, {bool interrupt = false}) {
    chat.permissions.deny(message, interrupt: interrupt);
    chat.session.notifyPermissionQueueChanged();
  }

  /// Handles the "clear context + plan approval" workflow.
  ///
  /// 1. Allows the ExitPlanMode permission (so CLI gets a response)
  /// 2. Resets the session (clears context)
  /// 3. Switches to acceptEdits mode
  /// 4. Starts a new session with the plan text as the prompt
  Future<void> approvePlanWithClearContext(Chat chat, String planText) async {
    // 1. Allow the ExitPlanMode permission first
    allowPermission(
      chat,
      updatedPermissions: [
        {'type': 'setMode', 'mode': 'acceptEdits', 'destination': 'session'},
      ],
    );

    // 2. Reset session (clears context, stops session)
    await chat.session.reset();

    // 3. Switch to acceptEdits mode for the new session
    chat.settings.setPermissionMode(PermissionMode.acceptEdits);

    // 4. Start new session with plan as prompt
    final prompt =
        'The user has approved your plan and wants you to execute it '
        'with a clear context. Here is the approved plan:\n\n'
        '$planText\n\n'
        'Begin implementation.';

    chat.conversations.addEntry(
      UserInputEntry(
        timestamp: DateTime.now(),
        text: '[Plan approved - clear context + accept edits]',
      ),
    );

    try {
      await chat.session.start(
        backend: _backend,
        eventHandler: _eventHandler,
        prompt: prompt,
        internalToolsService: _internalTools,
      );
    } catch (e) {
      chat.conversations.addEntry(
        TextOutputEntry(
          timestamp: DateTime.now(),
          text: 'Failed to start session: $e',
          contentType: 'error',
        ),
      );
    }
  }

  /// Starts a session on the given chat with the specified prompt.
  ///
  /// If [showInConversation] is true (default), adds a [UserInputEntry]
  /// before starting the session. Set to false for hidden prompts
  /// (e.g. conflict resolution preambles).
  Future<void> startSession(
    Chat chat, {
    required String prompt,
    List<AttachedImage> images = const [],
    bool showInConversation = true,
    DisplayFormat displayFormat = DisplayFormat.plain,
    String? systemPromptAppend,
  }) async {
    if (showInConversation) {
      chat.conversations.addEntry(
        UserInputEntry(
          timestamp: DateTime.now(),
          text: prompt,
          images: images,
          displayFormat: displayFormat,
        ),
      );
    }

    try {
      await chat.session.start(
        backend: _backend,
        eventHandler: _eventHandler,
        prompt: prompt,
        images: images,
        internalToolsService: _internalTools,
        systemPromptAppend: systemPromptAppend,
      );
    } catch (e) {
      chat.conversations.addEntry(
        TextOutputEntry(
          timestamp: DateTime.now(),
          text: 'Failed to start session: $e',
          contentType: 'error',
        ),
      );
    }
  }
}
