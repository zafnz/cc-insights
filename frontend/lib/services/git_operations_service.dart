import 'dart:developer' as developer;

import '../models/chat.dart';
import '../models/chat_model.dart';
import '../models/output_entry.dart';
import '../models/project.dart';
import '../models/worktree.dart';
import '../services/runtime_config.dart';
import '../state/selection_state.dart';
import 'chat_session_service.dart';
import 'git_service.dart';
import 'log_service.dart';
import 'project_restore_service.dart';

/// Result of a git operation.
class GitOpResult {
  final bool success;
  final String? errorMessage;

  const GitOpResult.ok() : success = true, errorMessage = null;
  const GitOpResult.error(this.errorMessage) : success = false;
}

/// Service for git operations triggered from the information panel.
///
/// Encapsulates push, conflict abort/continue, and conflict resolution chat
/// creation. Dialog-showing operations remain on the widget since they need
/// [BuildContext].
class GitOperationsService {
  final GitService _git;
  final ChatSessionService _chatSession;
  final ProjectRestoreService _restoreService;

  GitOperationsService({
    required GitService git,
    required ChatSessionService chatSession,
    required ProjectRestoreService restoreService,
  }) : _git = git,
       _chatSession = chatSession,
       _restoreService = restoreService;

  /// Pushes the current branch to remote.
  Future<GitOpResult> push(
    String worktreeRoot, {
    bool setUpstream = false,
  }) async {
    try {
      await _git.push(worktreeRoot, setUpstream: setUpstream);
      return const GitOpResult.ok();
    } catch (e) {
      return GitOpResult.error('Push failed: $e');
    }
  }

  /// Aborts an in-progress conflict (rebase or merge).
  Future<GitOpResult> abortConflict(
    String worktreeRoot,
    MergeOperationType? operation,
  ) async {
    try {
      if (operation == MergeOperationType.rebase) {
        await _git.rebaseAbort(worktreeRoot);
      } else {
        await _git.mergeAbort(worktreeRoot);
      }
      return const GitOpResult.ok();
    } catch (e) {
      return GitOpResult.error('Failed to abort: $e');
    }
  }

  /// Continues an in-progress conflict after resolution.
  Future<GitOpResult> continueConflict(
    String worktreeRoot,
    MergeOperationType? operation,
  ) async {
    try {
      if (operation == MergeOperationType.rebase) {
        await _git.rebaseContinue(worktreeRoot);
      } else {
        await _git.mergeContinue(worktreeRoot);
      }
      return const GitOpResult.ok();
    } catch (e) {
      return GitOpResult.error('Failed to continue: $e');
    }
  }

  /// Opens a conflict manager chat with Claude.
  ///
  /// Creates a new chat, sets the AI model, adds it to the worktree,
  /// selects it, persists it, and starts a session with a conflict
  /// resolution preamble.
  Future<void> openConflictManagerChat({
    required WorktreeState worktree,
    required ProjectState project,
    required SelectionState selection,
    required String branch,
    required String mainBranch,
    required String worktreePath,
    required String mainWorktreePath,
    required MergeOperationType operation,
  }) async {
    final operationName = operation == MergeOperationType.rebase
        ? 'rebasing'
        : 'merging';

    // Build the preamble (sent to Claude but NOT shown in UI)
    final preamble =
        'The user is $operationName this child branch '
        '($branch) onto its parent ($mainBranch), and has '
        'encountered a number of merge conflicts. You are to resolve '
        'the conflicts where the solution is obvious go ahead. If '
        'the conflict is not obvious or you may break something STOP '
        'and advise the user.\n'
        'Rules:\n'
        '- Do NOT use origin, only local.\n'
        '- This branch is $branch: $worktreePath\n'
        '- Parent is $mainBranch: $mainWorktreePath\n'
        '- Do NOT do destructive edits\n'
        '- Always ask the user if it is a complicated conflict '
        'resolution.\n\n'
        'Now analyse the conflict and begin work resolving it.';

    // Create the chat
    final chatName =
        'Conflict: $operationName $branch '
        'onto $mainBranch';
    final chatData = ChatData.create(
      name: chatName,
      worktreeRoot: worktreePath,
      isAutoGeneratedName: false,
    );
    final chat = Chat(chatData);

    // Set the model to the AI assistance model
    final aiModel = RuntimeConfig.instance.aiAssistanceModel;
    if (aiModel != 'disabled') {
      final backend = RuntimeConfig.instance.defaultBackend;
      chat.settings.setModel(
        ChatModelCatalog.defaultForBackend(backend, aiModel),
      );
    }

    // Add to worktree and select it
    worktree.addChat(chat, select: true);
    selection.selectChat(chat);

    // Persist the new chat (fire-and-forget)
    _restoreService
        .addChatToWorktree(
          project.data.repoRoot,
          worktree.data.worktreeRoot,
          chat,
        )
        .catchError((error) {
          developer.log(
            'Failed to persist conflict chat: $error',
            name: 'GitOperationsService',
            level: 900,
          );
        });

    // Start the session with the preamble as the prompt.
    // We do NOT add a UserInputEntry so the preamble is invisible.
    await _chatSession.startSession(
      chat,
      prompt: preamble,
      showInConversation: false,
    );
  }

  /// Detects the main branch and opens a conflict resolution chat.
  ///
  /// Used by the "Ask Claude" button in the conflict-in-progress section.
  Future<void> askClaudeForConflict({
    required ProjectState project,
    required SelectionState selection,
    required WorktreeState worktree,
    required WorktreeData data,
  }) async {
    final mainBranch = await _git.getMainBranch(project.data.repoRoot);

    final operation = data.conflictOperation ?? MergeOperationType.merge;
    final mainWorktreePath = project.primaryWorktree.data.worktreeRoot;

    await openConflictManagerChat(
      worktree: worktree,
      project: project,
      selection: selection,
      branch: data.branch,
      mainBranch: mainBranch ?? 'main',
      worktreePath: data.worktreeRoot,
      mainWorktreePath: mainWorktreePath,
      operation: operation,
    );
  }
}
