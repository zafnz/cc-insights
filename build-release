#!/bin/bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Get the directory where this script lives
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Load environment variables from .env file
if [ -f "$SCRIPT_DIR/.env" ]; then
    set -a
    source "$SCRIPT_DIR/.env"
    set +a
else
    echo -e "${RED}Error: .env file not found.${NC}"
    echo "Please create a .env file with CODESIGN_IDENTITY and NOTARIZE_KEYCHAIN_PROFILE."
    echo "See .env.example for reference."
    exit 1
fi

# Validate required environment variables
if [ -z "$CODESIGN_IDENTITY" ]; then
    echo -e "${RED}Error: CODESIGN_IDENTITY not set in .env${NC}"
    exit 1
fi

if [ -z "$NOTARIZE_KEYCHAIN_PROFILE" ]; then
    echo -e "${RED}Error: NOTARIZE_KEYCHAIN_PROFILE not set in .env${NC}"
    exit 1
fi

echo -e "${YELLOW}=== CC Insights Release Build ===${NC}"

# 1. Check for uncommitted or unstaged changes
echo -e "\n${YELLOW}Checking for uncommitted changes...${NC}"
if ! git diff --quiet || ! git diff --cached --quiet; then
    echo -e "${RED}Error: There are uncommitted or staged changes.${NC}"
    echo "Please commit or stash your changes before building a release."
    git status --short
    exit 1
fi

if [ -n "$(git ls-files --others --exclude-standard)" ]; then
    echo -e "${RED}Error: There are untracked files.${NC}"
    echo "Please commit or remove untracked files before building a release."
    git ls-files --others --exclude-standard
    exit 1
fi

echo -e "${GREEN}Working directory is clean.${NC}"

# 2. Check that we're on main branch and up-to-date with origin
echo -e "\n${YELLOW}Checking branch status...${NC}"
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "main" ]; then
    echo -e "${RED}Error: Not on main branch (currently on ${CURRENT_BRANCH}).${NC}"
    echo "Please checkout main before building a release."
    exit 1
fi

echo -e "${YELLOW}Fetching latest from origin...${NC}"
git fetch origin main

LOCAL_HASH=$(git rev-parse HEAD)
REMOTE_HASH=$(git rev-parse origin/main)

if [ "$LOCAL_HASH" != "$REMOTE_HASH" ]; then
    # Check if local is behind, ahead, or diverged
    MERGE_BASE=$(git merge-base HEAD origin/main)
    if [ "$MERGE_BASE" = "$LOCAL_HASH" ]; then
        echo -e "${RED}Error: Local branch is behind origin/main.${NC}"
        echo "Please run 'git pull' to update before building a release."
    elif [ "$MERGE_BASE" = "$REMOTE_HASH" ]; then
        echo -e "${RED}Error: Local branch is ahead of origin/main.${NC}"
        echo "Please push your changes or reset to origin/main before building a release."
    else
        echo -e "${RED}Error: Local branch has diverged from origin/main.${NC}"
        echo "Please synchronize with origin/main before building a release."
    fi
    exit 1
fi

echo -e "${GREEN}Branch is up-to-date with origin/main.${NC}"

# 3. Read current version from pubspec.yaml
PUBSPEC="$SCRIPT_DIR/frontend/pubspec.yaml"
CURRENT_VERSION=$(grep "^version:" "$PUBSPEC" | sed 's/version: //')
echo -e "\n${YELLOW}Current version: ${CURRENT_VERSION}${NC}"

# Parse version components (assuming semver: major.minor.patch)
IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

# Increment patch version
NEW_PATCH=$((PATCH + 1))
NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
echo -e "${GREEN}New version: ${NEW_VERSION}${NC}"

# 4. Update version in pubspec.yaml
echo -e "\n${YELLOW}Updating pubspec.yaml...${NC}"
sed -i '' "s/^version: .*/version: ${NEW_VERSION}/" "$PUBSPEC"

# 5. Commit the version bump and push (triggers Windows/Linux CI builds)
echo -e "\n${YELLOW}Committing version bump...${NC}"
git add "$PUBSPEC"
git commit -m "Bump version to ${NEW_VERSION}"
TAG="v${NEW_VERSION}"
git tag "$TAG"

echo -e "\n${YELLOW}Pushing commit and tag (triggers Windows/Linux CI builds)...${NC}"
git push && git push origin "$TAG"

# 6. Build the release
echo -e "\n${YELLOW}Building macOS release...${NC}"
cd "$SCRIPT_DIR/frontend"
flutter build macos --release

# 7. Code sign the app
APP_PATH="$SCRIPT_DIR/frontend/build/macos/Build/Products/Release/CC Insights.app"
echo -e "\n${YELLOW}Code signing the app...${NC}"
codesign --deep --force --options runtime --sign "$CODESIGN_IDENTITY" "$APP_PATH"

# Verify the signature
echo -e "\n${YELLOW}Verifying code signature...${NC}"
codesign --verify --deep --strict --verbose=2 "$APP_PATH"

# 8. Create zip for notarization
echo -e "\n${YELLOW}Creating zip for notarization...${NC}"
cd "$SCRIPT_DIR/frontend/build/macos/Build/Products/Release"
ZIP_NAME="cc-insights-macos.zip"
rm -f "$ZIP_NAME"
zip -ry "$ZIP_NAME" "CC Insights.app"

# 9. Submit for notarization and wait
echo -e "\n${YELLOW}Submitting for notarization (this may take a few minutes)...${NC}"
xcrun notarytool submit "$ZIP_NAME" --keychain-profile "$NOTARIZE_KEYCHAIN_PROFILE" --wait

# 10. Staple the notarization ticket
echo -e "\n${YELLOW}Stapling notarization ticket...${NC}"
xcrun stapler staple "$APP_PATH"

# 11. Recreate the zip with the stapled app
echo -e "\n${YELLOW}Creating final zip with stapled app...${NC}"
rm -f "$ZIP_NAME"
zip -ry "$ZIP_NAME" "CC Insights.app"

# 12. Create DMG
echo -e "\n${YELLOW}Creating DMG installer...${NC}"
DMG_NAME="cc-insights-macos.dmg"
rm -f "$DMG_NAME"
create-dmg \
    --volname "CC Insights" \
    --window-pos 200 120 \
    --window-size 600 400 \
    --icon-size 100 \
    --icon "CC Insights.app" 150 190 \
    --app-drop-link 450 190 \
    "$DMG_NAME" \
    "CC Insights.app" \
    || true  # create-dmg returns non-zero when it can't sign the DMG, but the DMG is still created

# Verify DMG was created
if [ ! -f "$DMG_NAME" ]; then
    echo -e "${RED}Error: DMG creation failed.${NC}"
    exit 1
fi

# 13. Notarize and staple the DMG
echo -e "\n${YELLOW}Notarizing DMG...${NC}"
xcrun notarytool submit "$DMG_NAME" --keychain-profile "$NOTARIZE_KEYCHAIN_PROFILE" --wait
xcrun stapler staple "$DMG_NAME"

# 14. Calculate SHA256 checksums
echo -e "\n${YELLOW}Calculating SHA256 checksums...${NC}"
SHA256_ZIP=$(shasum -a 256 "$ZIP_NAME" | awk '{print $1}')
SHA256_DMG=$(shasum -a 256 "$DMG_NAME" | awk '{print $1}')

# 15. Create GitHub release and upload
echo -e "\n${YELLOW}Creating GitHub release v${NEW_VERSION}...${NC}"
gh release create "$TAG" \
    --title "CC Insights ${NEW_VERSION}" \
    --generate-notes \
    --draft \
    "$ZIP_NAME" \
    "$DMG_NAME"

# 16. Output results
echo -e "\n${GREEN}=== Release Complete ===${NC}"
echo -e "Version: ${NEW_VERSION}"
echo -e "Tag: ${TAG}"
echo -e "Zip: ${ZIP_NAME}"
echo -e "DMG: ${DMG_NAME}"
echo -e "\n${YELLOW}SHA256 checksums:${NC}"
echo -e "  ZIP (Homebrew): ${GREEN}${SHA256_ZIP}${NC}"
echo -e "  DMG:            ${GREEN}${SHA256_DMG}${NC}"
