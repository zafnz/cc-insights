{
  "timestamp": "2026-02-16T20:35:24.502291",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "codex/event/patch_apply_begin",
    "params": {
      "id": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "msg": {
        "type": "patch_apply_begin",
        "call_id": "call_Op4ubwEgcsRxKbYko9FP9nEG",
        "turn_id": "019c650e-18cf-7663-abf3-b7ccd0271815",
        "auto_approved": false,
        "changes": {
          "/Users/zaf/projects/.cc-insights-wt/cci/actions-panel-start-chat/frontend/lib/services/project_config_service.dart": {
            "type": "update",
            "unified_diff": "@@ -7,2 +7,3 @@\n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n@@ -106,4 +107,3 @@\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n@@ -111,7 +111,11 @@\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n@@ -147,4 +151,5 @@\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n",
            "move_path": null
          }
        }
      },
      "conversationId": "019c650e-18aa-7441-b190-c32beb4724e4"
    }
  }
}
{
  "timestamp": "2026-02-16T20:35:24.502691",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "item/started",
    "params": {
      "item": {
        "type": "fileChange",
        "id": "call_Op4ubwEgcsRxKbYko9FP9nEG",
        "changes": [
          {
            "path": "/Users/zaf/projects/.cc-insights-wt/cci/actions-panel-start-chat/frontend/lib/services/project_config_service.dart",
            "kind": {
              "type": "update",
              "move_path": null
            },
            "diff": "@@ -7,2 +7,3 @@\n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n@@ -106,4 +107,3 @@\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n@@ -111,7 +111,11 @@\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n@@ -147,4 +151,5 @@\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n"
          }
        ],
        "status": "inProgress"
      },
      "threadId": "019c650e-18aa-7441-b190-c32beb4724e4",
      "turnId": "019c650e-18cf-7663-abf3-b7ccd0271815"
    }
  }
}
{
  "timestamp": "2026-02-16T20:35:24.502889",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "codex/event/apply_patch_approval_request",
    "params": {
      "id": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "msg": {
        "type": "apply_patch_approval_request",
        "call_id": "call_Op4ubwEgcsRxKbYko9FP9nEG",
        "turn_id": "019c650e-18cf-7663-abf3-b7ccd0271815",
        "changes": {
          "/Users/zaf/projects/.cc-insights-wt/cci/actions-panel-start-chat/frontend/lib/services/project_config_service.dart": {
            "type": "update",
            "unified_diff": "@@ -7,2 +7,3 @@\n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n@@ -106,4 +107,3 @@\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n@@ -111,7 +111,11 @@\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n@@ -147,4 +151,5 @@\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n",
            "move_path": null
          }
        }
      },
      "conversationId": "019c650e-18aa-7441-b190-c32beb4724e4"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:11.804422",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "codex/event/patch_apply_end",
    "params": {
      "id": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "msg": {
        "type": "patch_apply_end",
        "call_id": "call_Op4ubwEgcsRxKbYko9FP9nEG",
        "turn_id": "019c650e-18cf-7663-abf3-b7ccd0271815",
        "stdout": "Success. Updated the following files:\nM frontend/lib/services/project_config_service.dart\n",
        "stderr": "",
        "success": true,
        "changes": {
          "/Users/zaf/projects/.cc-insights-wt/cci/actions-panel-start-chat/frontend/lib/services/project_config_service.dart": {
            "type": "update",
            "unified_diff": "@@ -7,2 +7,3 @@\n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n@@ -106,4 +107,3 @@\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n@@ -111,7 +111,11 @@\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n@@ -147,4 +151,5 @@\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n",
            "move_path": null
          }
        }
      },
      "conversationId": "019c650e-18aa-7441-b190-c32beb4724e4"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:11.804708",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "item/completed",
    "params": {
      "item": {
        "type": "fileChange",
        "id": "call_Op4ubwEgcsRxKbYko9FP9nEG",
        "changes": [
          {
            "path": "/Users/zaf/projects/.cc-insights-wt/cci/actions-panel-start-chat/frontend/lib/services/project_config_service.dart",
            "kind": {
              "type": "update",
              "move_path": null
            },
            "diff": "@@ -7,2 +7,3 @@\n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n@@ -106,4 +107,3 @@\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n@@ -111,7 +111,11 @@\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n@@ -147,4 +151,5 @@\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n"
          }
        ],
        "status": "completed"
      },
      "threadId": "019c650e-18aa-7441-b190-c32beb4724e4",
      "turnId": "019c650e-18cf-7663-abf3-b7ccd0271815"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:11.804959",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "codex/event/turn_diff",
    "params": {
      "id": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "msg": {
        "type": "turn_diff",
        "unified_diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
      },
      "conversationId": "019c650e-18aa-7441-b190-c32beb4724e4"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:11.805305",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "turn/diff/updated",
    "params": {
      "threadId": "019c650e-18aa-7441-b190-c32beb4724e4",
      "turnId": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:11.857446",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "codex/event/turn_diff",
    "params": {
      "id": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "msg": {
        "type": "turn_diff",
        "unified_diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
      },
      "conversationId": "019c650e-18aa-7441-b190-c32beb4724e4"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:11.857986",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "turn/diff/updated",
    "params": {
      "threadId": "019c650e-18aa-7441-b190-c32beb4724e4",
      "turnId": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:44.747501",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "codex/event/turn_diff",
    "params": {
      "id": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "msg": {
        "type": "turn_diff",
        "unified_diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
      },
      "conversationId": "019c650e-18aa-7441-b190-c32beb4724e4"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:44.748020",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "turn/diff/updated",
    "params": {
      "threadId": "019c650e-18aa-7441-b190-c32beb4724e4",
      "turnId": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:53.097647",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "codex/event/turn_diff",
    "params": {
      "id": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "msg": {
        "type": "turn_diff",
        "unified_diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
      },
      "conversationId": "019c650e-18aa-7441-b190-c32beb4724e4"
    }
  }
}
{
  "timestamp": "2026-02-16T20:41:53.098122",
  "level": "debug",
  "direction": "stdout",
  "content": {
    "method": "turn/diff/updated",
    "params": {
      "threadId": "019c650e-18aa-7441-b190-c32beb4724e4",
      "turnId": "019c650e-18cf-7663-abf3-b7ccd0271815",
      "diff": "diff --git a/frontend/lib/models/project_config.dart b/frontend/lib/models/project_config.dart\nindex 94c0abfee8c1f7292bc34235f6a00d1b7090ea31..4968f1f7585cd39e7fdb92cd650677290b93f0e2\n--- a/frontend/lib/models/project_config.dart\n+++ b/frontend/lib/models/project_config.dart\n@@ -1,5 +1,7 @@\n import 'package:flutter/foundation.dart';\n \n+import 'user_action.dart';\n+\n /// Configuration for project-specific actions stored in .ccinsights/config.json.\n ///\n /// This configuration lives at the project root (not per-worktree) and contains:\n@@ -19,11 +21,10 @@\n \n   /// User-defined action buttons shown in the ActionsPanel.\n   ///\n-  /// Keys are button labels, values are shell commands.\n-  /// - If null: show default buttons (Test, Run)\n-  /// - If empty map {}: show no buttons\n-  /// - If populated: show only these buttons\n-  final Map<String, String>? userActions;\n+  /// - If null: show default actions (Test, Run)\n+  /// - If empty list: show no actions\n+  /// - If populated: show only these actions, in list order\n+  final List<UserAction>? userActions;\n \n   /// Default base branch/ref for merge and diff operations.\n   ///\n@@ -32,10 +33,10 @@\n   final String? defaultBase;\n \n   /// Default user actions shown when no config exists or userActions is null.\n-  static const Map<String, String> defaultUserActions = {\n-    'Test': './test.sh',\n-    'Run': './run.sh',\n-  };\n+  static const List<UserAction> defaultUserActions = [\n+    CommandAction(name: 'Test', command: './test.sh'),\n+    CommandAction(name: 'Run', command: './run.sh'),\n+  ];\n \n   const ProjectConfig({\n     this.actions = const {},\n@@ -52,8 +53,8 @@\n   /// Returns the effective user actions to display.\n   ///\n   /// - Returns [defaultUserActions] if [userActions] is null\n-  /// - Returns the actual [userActions] map otherwise (may be empty)\n-  Map<String, String> get effectiveUserActions =>\n+  /// - Returns the actual [userActions] list otherwise (may be empty)\n+  List<UserAction> get effectiveUserActions =>\n       userActions ?? defaultUserActions;\n \n   /// Whether this config has any lifecycle hooks defined.\n@@ -65,7 +66,7 @@\n   /// Creates a copy with updated fields.\n   ProjectConfig copyWith({\n     Map<String, String>? actions,\n-    Map<String, String>? userActions,\n+    List<UserAction>? userActions,\n     bool clearUserActions = false,\n     String? defaultBase,\n     bool clearDefaultBase = false,\n@@ -84,13 +85,24 @@\n     final userActionsJson = json['user-actions'];\n     final defaultBaseJson = json['default-base'];\n \n+    List<UserAction>? parsedUserActions;\n+    if (userActionsJson is Map) {\n+      parsedUserActions = userActionsJson.entries\n+          .where((entry) => entry.key is String)\n+          .map(\n+            (entry) => UserAction.fromJson(\n+              entry.key as String,\n+              entry.value,\n+            ),\n+          )\n+          .toList();\n+    }\n+\n     return ProjectConfig(\n       actions: actionsJson is Map\n           ? Map<String, String>.from(actionsJson)\n           : const {},\n-      userActions: userActionsJson is Map\n-          ? Map<String, String>.from(userActionsJson)\n-          : null,\n+      userActions: parsedUserActions,\n       defaultBase: defaultBaseJson is String ? defaultBaseJson : null,\n     );\n   }\n@@ -99,7 +111,10 @@\n   Map<String, dynamic> toJson() {\n     return {\n       if (actions.isNotEmpty) 'actions': actions,\n-      if (userActions != null) 'user-actions': userActions,\n+      if (userActions != null)\n+        'user-actions': {\n+          for (final action in userActions!) action.name: action.toJsonValue(),\n+        },\n       if (defaultBase != null) 'default-base': defaultBase,\n     };\n   }\n@@ -109,14 +124,14 @@\n     if (identical(this, other)) return true;\n     return other is ProjectConfig &&\n         mapEquals(other.actions, actions) &&\n-        mapEquals(other.userActions, userActions) &&\n+        listEquals(other.userActions, userActions) &&\n         other.defaultBase == defaultBase;\n   }\n \n   @override\n   int get hashCode => Object.hash(\n         Object.hashAll(actions.entries),\n-        userActions != null ? Object.hashAll(userActions!.entries) : null,\n+        userActions != null ? Object.hashAll(userActions!) : null,\n         defaultBase,\n       );\n \ndiff --git a/frontend/lib/models/user_action.dart b/frontend/lib/models/user_action.dart\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..a7b319809637101d3f746bcd81854738fd31307d\n--- /dev/null\n+++ b/frontend/lib/models/user_action.dart\n@@ -0,0 +1,162 @@\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/material.dart';\n+\n+/// Base type for a user-defined action shown in the Actions panel.\n+@immutable\n+sealed class UserAction {\n+  const UserAction({required this.name});\n+\n+  /// Display name shown on the action button.\n+  final String name;\n+\n+  /// Icon used in the Actions panel.\n+  IconData get icon;\n+\n+  /// JSON value stored under this action's key in `user-actions`.\n+  Object toJsonValue();\n+\n+  /// Parses a user action from a `user-actions` entry.\n+  ///\n+  /// Backward compatible behavior:\n+  /// - String value => [CommandAction]\n+  /// - Object with `type: \"start-chat\"` => [StartChatMacro]\n+  /// - Object with `type: \"command\"` => [CommandAction]\n+  factory UserAction.fromJson(String name, Object? value) {\n+    if (value is String) {\n+      return CommandAction(name: name, command: value);\n+    }\n+\n+    if (value is Map) {\n+      final type = value['type'] as String?;\n+      if (type == 'start-chat') {\n+        final modelRaw = value['model'];\n+        final model = modelRaw is String && modelRaw.trim().isNotEmpty\n+            ? modelRaw.trim()\n+            : null;\n+        return StartChatMacro(\n+          name: name,\n+          agentId: value['agent-id'] as String? ?? 'claude-default',\n+          model: model,\n+          instruction: value['instruction'] as String? ?? '',\n+        );\n+      }\n+\n+      if (type == 'command') {\n+        return CommandAction(\n+          name: name,\n+          command: value['command'] as String? ?? '',\n+        );\n+      }\n+    }\n+\n+    return CommandAction(name: name, command: '');\n+  }\n+}\n+\n+/// Shell command action.\n+@immutable\n+class CommandAction extends UserAction {\n+  const CommandAction({\n+    required super.name,\n+    required this.command,\n+  });\n+\n+  /// Shell command to execute.\n+  final String command;\n+\n+  @override\n+  IconData get icon => Icons.play_arrow;\n+\n+  @override\n+  Object toJsonValue() {\n+    if (command.trim().isNotEmpty) {\n+      return command;\n+    }\n+    return {\n+      'type': 'command',\n+      'command': command,\n+    };\n+  }\n+\n+  CommandAction copyWith({\n+    String? name,\n+    String? command,\n+  }) {\n+    return CommandAction(\n+      name: name ?? this.name,\n+      command: command ?? this.command,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is CommandAction &&\n+        other.name == name &&\n+        other.command == command;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, command);\n+}\n+\n+/// Macro action that creates and starts a new chat.\n+@immutable\n+class StartChatMacro extends UserAction {\n+  const StartChatMacro({\n+    required super.name,\n+    required this.agentId,\n+    this.model,\n+    required this.instruction,\n+  });\n+\n+  /// Agent config ID used to start the chat.\n+  final String agentId;\n+\n+  /// Optional model override. Null uses the agent default model.\n+  final String? model;\n+\n+  /// Initial instruction sent as the first user message.\n+  final String instruction;\n+\n+  @override\n+  IconData get icon => Icons.chat_bubble_outline;\n+\n+  @override\n+  Object toJsonValue() {\n+    return {\n+      'type': 'start-chat',\n+      'agent-id': agentId,\n+      if (model != null && model!.trim().isNotEmpty) 'model': model,\n+      'instruction': instruction,\n+    };\n+  }\n+\n+  StartChatMacro copyWith({\n+    String? name,\n+    String? agentId,\n+    String? model,\n+    bool clearModel = false,\n+    String? instruction,\n+  }) {\n+    return StartChatMacro(\n+      name: name ?? this.name,\n+      agentId: agentId ?? this.agentId,\n+      model: clearModel ? null : (model ?? this.model),\n+      instruction: instruction ?? this.instruction,\n+    );\n+  }\n+\n+  @override\n+  bool operator ==(Object other) {\n+    if (identical(this, other)) return true;\n+    return other is StartChatMacro &&\n+        other.name == name &&\n+        other.agentId == agentId &&\n+        other.model == model &&\n+        other.instruction == instruction;\n+  }\n+\n+  @override\n+  int get hashCode => Object.hash(name, agentId, model, instruction);\n+}\ndiff --git a/frontend/lib/services/project_config_service.dart b/frontend/lib/services/project_config_service.dart\nindex 61ce0f38b4956e3cedfa0abf3ecc79a2a793f6d4..fe45ab8257d19bead98f7b21960a31d6baee4939\n--- a/frontend/lib/services/project_config_service.dart\n+++ b/frontend/lib/services/project_config_service.dart\n@@ -5,6 +5,7 @@\n import 'package:flutter/foundation.dart';\n \n import '../models/project_config.dart';\n+import '../models/user_action.dart';\n \n /// Service for reading and writing project configuration files.\n ///\n@@ -104,16 +105,19 @@\n   /// Loads the existing config, updates the action, and saves.\n   Future<void> updateUserAction(\n     String projectRoot,\n-    String actionName,\n-    String command,\n+    UserAction action,\n   ) async {\n     final config = await loadConfig(projectRoot);\n \n-    // Create new user actions map, preserving existing ones\n-    final newUserActions = Map<String, String>.from(\n-      config.userActions ?? {},\n+    final newUserActions = List<UserAction>.from(config.userActions ?? const []);\n+    final existingIndex = newUserActions.indexWhere(\n+      (existing) => existing.name == action.name,\n     );\n-    newUserActions[actionName] = command;\n+    if (existingIndex >= 0) {\n+      newUserActions[existingIndex] = action;\n+    } else {\n+      newUserActions.add(action);\n+    }\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n@@ -145,8 +149,9 @@\n \n     if (config.userActions == null) return;\n \n-    final newUserActions = Map<String, String>.from(config.userActions!);\n-    newUserActions.remove(actionName);\n+    final newUserActions = config.userActions!\n+        .where((action) => action.name != actionName)\n+        .toList();\n \n     final updatedConfig = config.copyWith(userActions: newUserActions);\n     await saveConfig(projectRoot, updatedConfig);\n"
    }
  }
}
