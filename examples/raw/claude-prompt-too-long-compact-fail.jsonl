{"timestamp":"2026-02-09T20:35:44.937740","level":"debug","direction":"stdout","content":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dn7PHq9CU3AZuaFsknZHD8","type":"tool_result","content":"     1→# Securely deploying AI agents\n     2→\n     3→A guide to securing Claude Code and Agent SDK deployments with isolation, credential management, and network controls\n     4→\n     5→---\n     6→\n     7→Claude Code and the Agent SDK are powerful tools that can execute code, access files, and interact with external services on your behalf. Like any tool with these capabilities, deploying them thoughtfully ensures you get the benefits while maintaining appropriate controls.\n     8→\n     9→Unlike traditional software that follows predetermined code paths, these tools generate their actions dynamically based on context and goals. This flexibility is what makes them useful, but it also means their behavior can be influenced by the content they process: files, webpages, or user input. This is sometimes called prompt injection. For example, if a repository's README contains unusual instructions, Claude Code might incorporate those into its actions in ways the operator didn't anticipate. This guide covers practical ways to reduce this risk.\n    10→\n    11→The good news is that securing an agent deployment doesn't require exotic infrastructure. The same principles that apply to running any semi-trusted code apply here: isolation, least privilege, and defense in depth. Claude Code includes several security features that help with common concerns, and this guide walks through these along with additional hardening options for those who need them.\n    12→\n    13→Not every deployment needs maximum security. A developer running Claude Code on their laptop has different requirements than a company processing customer data in a multi-tenant environment. This guide presents options ranging from Claude Code's built-in security features to hardened production architectures, so you can choose what fits your situation.\n    14→\n    15→## What are we protecting against?\n    16→\n    17→Agents can take unintended actions due to prompt injection (instructions embedded in content they process) or model error. Claude models are designed to resist this, and as we analyzed in our [model card](https://assets.anthropic.com/m/64823ba7485345a7/Claude-Opus-4-5-System-Card.pdf), we believe Claude Opus 4.5 is the most robust frontier model available.\n    18→\n    19→Defense in depth is still good practice though. For example, if an agent processes a malicious file that instructs it to send customer data to an external server, network controls can block that request entirely.\n    20→\n    21→## Built-in security features\n    22→\n    23→Claude Code includes several security features that address common concerns. See the [security documentation](https://code.claude.com/docs/en/security) for full details.\n    24→\n    25→- **Permissions system**: Every tool and bash command can be configured to allow, block, or prompt the user for approval. Use glob patterns to create rules like \"allow all npm commands\" or \"block any command with sudo\". Organizations can set policies that apply across all users. See [access control and permissions](https://code.claude.com/docs/en/iam#access-control-and-permissions).\n    26→- **Static analysis**: Before executing bash commands, Claude Code runs static analysis to identify potentially risky operations. Commands that modify system files or access sensitive directories are flagged and require explicit user approval.\n    27→- **Web search summarization**: Search results are summarized rather than passing raw content directly into the context, reducing the risk of prompt injection from malicious web content.\n    28→- **Sandbox mode**: Bash commands can run in a sandboxed environment that restricts filesystem and network access. See the [sandboxing documentation](https://code.claude.com/docs/en/sandboxing) for details.\n    29→\n    30→## Security principles\n    31→\n    32→For deployments that require additional hardening beyond Claude Code's defaults, these principles guide the available options.\n    33→\n    34→### Security boundaries\n    35→\n    36→A security boundary separates components with different trust levels. For high-security deployments, you can place sensitive resources (like credentials) outside the boundary containing the agent. If something goes wrong in the agent's environment, resources outside that boundary remain protected.\n    37→\n    38→For example, rather than giving an agent direct access to an API key, you could run a proxy outside the agent's environment that injects the key into requests. The agent can make API calls, but it never sees the credential itself. This pattern is useful for multi-tenant deployments or when processing untrusted content.\n    39→\n    40→### Least privilege\n    41→\n    42→When needed, you can restrict the agent to only the capabilities required for its specific task:\n    43→\n    44→| Resource | Restriction options |\n    45→|----------|---------------------|\n    46→| Filesystem | Mount only needed directories, prefer read-only |\n    47→| Network | Restrict to specific endpoints via proxy |\n    48→| Credentials | Inject via proxy rather than exposing directly |\n    49→| System capabilities | Drop Linux capabilities in containers |\n    50→\n    51→### Defense in depth\n    52→\n    53→For high-security environments, layering multiple controls provides additional protection. Options include:\n    54→\n    55→- Container isolation\n    56→- Network restrictions\n    57→- Filesystem controls\n    58→- Request validation at a proxy\n    59→\n    60→The right combination depends on your threat model and operational requirements.\n    61→\n    62→## Isolation technologies\n    63→\n    64→Different isolation technologies offer different tradeoffs between security strength, performance, and operational complexity.\n    65→\n    66→<Info>\n    67→In all of these configurations, Claude Code (or your Agent SDK application) runs inside the isolation boundary—the sandbox, container, or VM. The security controls described below restrict what the agent can access from within that boundary.\n    68→</Info>\n    69→\n    70→| Technology | Isolation strength | Performance overhead | Complexity |\n    71→|------------|-------------------|---------------------|------------|\n    72→| Sandbox runtime | Good (secure defaults) | Very low | Low |\n    73→| Containers (Docker) | Setup dependent | Low | Medium |\n    74→| gVisor | Excellent (with correct setup) | Medium/High | Medium |\n    75→| VMs (Firecracker, QEMU) | Excellent (with correct setup) | High | Medium/High |\n    76→\n    77→### Sandbox runtime\n    78→\n    79→For lightweight isolation without containers, [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime) enforces filesystem and network restrictions at the OS level.\n    80→\n    81→The main advantage is simplicity: no Docker configuration, container images, or networking setup required. The proxy and filesystem restrictions are built in. You provide a settings file specifying allowed domains and paths.\n    82→\n    83→**How it works:**\n    84→- **Filesystem**: Uses OS primitives (`bubblewrap` on Linux, `sandbox-exec` on macOS) to restrict read/write access to configured paths\n    85→- **Network**: Removes network namespace (Linux) or uses Seatbelt profiles (macOS) to route network traffic through a built-in proxy\n    86→- **Configuration**: JSON-based allowlists for domains and filesystem paths\n    87→\n    88→**Setup:**\n    89→```bash\n    90→npm install @anthropic-ai/sandbox-runtime\n    91→```\n    92→\n    93→Then create a configuration file specifying allowed paths and domains.\n    94→\n    95→**Security considerations:**\n    96→\n    97→1. **Same-host kernel**: Unlike VMs, sandboxed processes share the host kernel. A kernel vulnerability could theoretically enable escape. For some threat models this is acceptable, but if you need kernel-level isolation, use gVisor or a separate VM.\n    98→\n    99→2. **No TLS inspection**: The proxy allowlists domains but doesn't inspect encrypted traffic. If the agent has permissive credentials for an allowed domain, ensure it isn't possible to use that domain to trigger other network requests or to exfiltrate data.\n   100→\n   101→For many single-developer and CI/CD use cases, sandbox-runtime raises the bar significantly with minimal setup. The sections below cover containers and VMs for deployments requiring stronger isolation.\n   102→\n   103→### Containers\n   104→\n   105→Containers provide isolation through Linux namespaces. Each container has its own view of the filesystem, process tree, and network stack, while sharing the host kernel.\n   106→\n   107→A security-hardened container configuration might look like this:\n   108→\n   109→```bash\n   110→docker run \\\n   111→  --cap-drop ALL \\\n   112→  --security-opt no-new-privileges \\\n   113→  --security-opt seccomp=/path/to/seccomp-profile.json \\\n   114→  --read-only \\\n   115→  --tmpfs /tmp:rw,noexec,nosuid,size=100m \\\n   116→  --tmpfs /home/agent:rw,noexec,nosuid,size=500m \\\n   117→  --network none \\\n   118→  --memory 2g \\\n   119→  --cpus 2 \\\n   120→  --pids-limit 100 \\\n   121→  --user 1000:1000 \\\n   122→  -v /path/to/code:/workspace:ro \\\n   123→  -v /var/run/proxy.sock:/var/run/proxy.sock:ro \\\n   124→  agent-image\n   125→```\n   126→\n   127→Here's what each option does:\n   128→\n   129→| Option | Purpose |\n   130→|--------|---------|\n   131→| `--cap-drop ALL` | Removes Linux capabilities like `NET_ADMIN` and `SYS_ADMIN` that could enable privilege escalation |\n   132→| `--security-opt no-new-privileges` | Prevents processes from gaining privileges through setuid binaries |\n   133→| `--security-opt seccomp=...` | Restricts available syscalls; Docker's default blocks ~44, custom profiles can block more |\n   134→| `--read-only` | Makes the container's root filesystem immutable, preventing the agent from persisting changes |\n   135→| `--tmpfs /tmp:...` | Provides a writable temporary directory that's cleared when the container stops |\n   136→| `--network none` | Removes all network interfaces; the agent communicates through the mounted Unix socket below |\n   137→| `--memory 2g` | Limits memory usage to prevent resource exhaustion |\n   138→| `--pids-limit 100` | Limits process count to prevent fork bombs |\n   139→| `--user 1000:1000` | Runs as a non-root user |\n   140→| `-v ...:/workspace:ro` | Mounts code read-only so the agent can analyze but not modify it. **Avoid mounting sensitive host directories like `~/.ssh`, `~/.aws`, or `~/.config`** |\n   141→| `-v .../proxy.sock:...` | Mounts a Unix socket connected to a proxy running outside the container (see below) |\n   142→\n   143→**Unix socket architecture:**\n   144→\n   145→With `--network none`, the container has no network interfaces at all. The only way for the agent to reach the outside world is through the mounted Unix socket, which connects to a proxy running on the host. This proxy can enforce domain allowlists, inject credentials, and log all traffic.\n   146→\n   147→This is the same architecture used by [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime). Even if the agent is compromised via prompt injection, it cannot exfiltrate data to arbitrary servers—it can only communicate through the proxy, which controls what domains are reachable. For more details, see the [Claude Code sandboxing blog post](https://www.anthropic.com/engineering/claude-code-sandboxing).\n   148→\n   149→**Additional hardening options:**\n   150→\n   151→| Option | Purpose |\n   152→|--------|---------|\n   153→| `--userns-remap` | Maps container root to unprivileged host user; requires daemon configuration but limits damage from container escape |\n   154→| `--ipc private` | Isolates inter-process communication to prevent cross-container attacks |\n   155→\n   156→### gVisor\n   157→\n   158→Standard containers share the host kernel: when code inside a container makes a system call, it goes directly to the same kernel that runs the host. This means a kernel vulnerability could allow container escape. gVisor addresses this by intercepting system calls in userspace before they reach the host kernel, implementing its own compatibility layer that handles most syscalls without involving the real kernel.\n   159→\n   160→If an agent runs malicious code (perhaps due to prompt injection), that code runs in the container and could attempt kernel exploits. With gVisor, the attack surface is much smaller: the malicious code would need to exploit gVisor's userspace implementation first and would have limited access to the real kernel.\n   161→\n   162→To use gVisor with Docker, install the `runsc` runtime and configure the daemon:\n   163→\n   164→```json\n   165→// /etc/docker/daemon.json\n   166→{\n   167→  \"runtimes\": {\n   168→    \"runsc\": {\n   169→      \"path\": \"/usr/local/bin/runsc\"\n   170→    }\n   171→  }\n   172→}\n   173→```\n   174→\n   175→Then run containers with:\n   176→\n   177→```bash\n   178→docker run --runtime=runsc agent-image\n   179→```\n   180→\n   181→**Performance considerations:**\n   182→\n   183→| Workload | Overhead |\n   184→|----------|----------|\n   185→| CPU-bound computation | ~0% (no syscall interception) |\n   186→| Simple syscalls | ~2× slower |\n   187→| File I/O intensive | Up to 10-200× slower for heavy open/close patterns |\n   188→\n   189→For multi-tenant environments or when processing untrusted content, the additional isolation is often worth the overhead.\n   190→\n   191→### Virtual machines\n   192→\n   193→VMs provide hardware-level isolation through CPU virtualization extensions. Each VM runs its own kernel, creating a strong boundary—a vulnerability in the guest kernel doesn't directly compromise the host. However, VMs aren't automatically \"more secure\" than alternatives like gVisor. VM security depends heavily on the hypervisor and device emulation code.\n   194→\n   195→Firecracker is designed for lightweight microVM isolation—it can boot VMs in under 125ms with less than 5 MiB memory overhead, stripping away unnecessary device emulation to reduce attack surface.\n   196→\n   197→With this approach, the agent VM has no external network interface. Instead, it communicates through `vsock` (virtual sockets). All traffic routes through vsock to a proxy on the host, which enforces allowlists and injects credentials before forwarding requests.\n   198→\n   199→### Cloud deployments\n   200→\n   201→For cloud deployments, you can combine any of the above isolation technologies with cloud-native network controls:\n   202→\n   203→1. Run agent containers in a private subnet with no internet gateway\n   204→2. Configure cloud firewall rules (AWS Security Groups, GCP VPC firewall) to block all egress except to your proxy\n   205→3. Run a proxy (such as [Envoy](https://www.envoyproxy.io/) with its `credential_injector` filter) that validates requests, enforces domain allowlists, injects credentials, and forwards to external APIs\n   206→4. Assign minimal IAM permissions to the agent's service account, routing sensitive access through the proxy where possible\n   207→5. Log all traffic at the proxy for audit purposes\n   208→\n   209→## Credential management\n   210→\n   211→Agents often need credentials to call APIs, access repositories, or interact with cloud services. The challenge is providing this access without exposing the credentials themselves.\n   212→\n   213→### The proxy pattern\n   214→\n   215→The recommended approach is to run a proxy outside the agent's security boundary that injects credentials into outgoing requests. The agent sends requests without credentials, the proxy adds them, and forwards the request to its destination.\n   216→\n   217→This pattern has several benefits:\n   218→\n   219→1. The agent never sees the actual credentials\n   220→2. The proxy can enforce an allowlist of permitted endpoints\n   221→3. The proxy can log all requests for auditing\n   222→4. Credentials are stored in one secure location rather than distributed to each agent\n   223→\n   224→### Configuring Claude Code to use a proxy\n   225→\n   226→Claude Code supports two methods for routing sampling requests through a proxy:\n   227→\n   228→**Option 1: ANTHROPIC_BASE_URL (simple but only for sampling API requests)**\n   229→\n   230→```bash\n   231→export ANTHROPIC_BASE_URL=\"http://localhost:8080\"\n   232→```\n   233→\n   234→This tells Claude Code and the Agent SDK to send sampling requests to your proxy instead of the Anthropic API directly. Your proxy receives plaintext HTTP requests, can inspect and modify them (including injecting credentials), then forwards to the real API.\n   235→\n   236→**Option 2: HTTP_PROXY / HTTPS_PROXY (system-wide)**\n   237→\n   238→```bash\n   239→export HTTP_PROXY=\"http://localhost:8080\"\n   240→export HTTPS_PROXY=\"http://localhost:8080\"\n   241→```\n   242→\n   243→Claude Code and the Agent SDK respect these standard environment variables, routing all HTTP traffic through the proxy. For HTTPS, the proxy creates an encrypted CONNECT tunnel: it cannot see or modify request contents without TLS interception.\n   244→\n   245→### Implementing a proxy\n   246→\n   247→You can build your own proxy or use an existing one:\n   248→\n   249→- [Envoy Proxy](https://www.envoyproxy.io/) — production-grade proxy with `credential_injector` filter for adding auth headers\n   250→- [mitmproxy](https://mitmproxy.org/) — TLS-terminating proxy for inspecting and modifying HTTPS traffic\n   251→- [Squid](http://www.squid-cache.org/) — caching proxy with access control lists\n   252→- [LiteLLM](https://github.com/BerriAI/litellm) — LLM gateway with credential injection and rate limiting\n   253→\n   254→### Credentials for other services\n   255→\n   256→Beyond sampling from the Anthropic API, agents often need authenticated access to other services—git repositories, databases, internal APIs. There are two main approaches:\n   257→\n   258→#### Custom tools\n   259→\n   260→Provide access through an MCP server or custom tool that routes requests to a service running outside the agent's security boundary. The agent calls the tool, but the actual authenticated request happens outside—the tool calls to a proxy which injects the credentials.\n   261→\n   262→For example, a git MCP server could accept commands from the agent but forward them to a git proxy running on the host, which adds authentication before contacting the remote repository. The agent never sees the credentials.\n   263→\n   264→Advantages:\n   265→- **No TLS interception**: The external service makes authenticated requests directly\n   266→- **Credentials stay outside**: The agent only sees the tool interface, not the underlying credentials\n   267→\n   268→#### Traffic forwarding\n   269→\n   270→For Anthropic API calls, `ANTHROPIC_BASE_URL` lets you route requests to a proxy that can inspect and modify them in plaintext. But for other HTTPS services (GitHub, npm registries, internal APIs), the traffic is often encrypted end-to-end—even if you route it through a proxy via `HTTP_PROXY`, the proxy only sees an opaque TLS tunnel and can't inject credentials.\n   271→\n   272→To modify HTTPS traffic to arbitrary services, without using a custom tool, you need a TLS-terminating proxy that decrypts traffic, inspects or modifies it, then re-encrypts it before forwarding. This requires:\n   273→\n   274→1. Running the proxy outside the agent's container\n   275→2. Installing the proxy's CA certificate in the agent's trust store (so the agent trusts the proxy's certificates)\n   276→3. Configuring `HTTP_PROXY`/`HTTPS_PROXY` to route traffic through the proxy\n   277→\n   278→This approach handles any HTTP-based service without writing custom tools, but adds complexity around certificate management.\n   279→\n   280→Note that not all programs respect `HTTP_PROXY`/`HTTPS_PROXY`. Most tools (curl, pip, npm, git) do, but some may bypass these variables and connect directly. For example, Node.js `fetch()` ignores these variables by default; in Node 24+ you can set `NODE_USE_ENV_PROXY=1` to enable support. For comprehensive coverage, you can use [proxychains](https://github.com/haad/proxychains) to intercept network calls, or configure iptables to redirect outbound traffic to a transparent proxy.\n   281→\n   282→<Info>\n   283→A **transparent proxy** intercepts traffic at the network level, so the client doesn't need to be configured to use it. Regular proxies require clients to explicitly connect and speak HTTP CONNECT or SOCKS. Transparent proxies (like Squid or mitmproxy in transparent mode) can handle raw redirected TCP connections.\n   284→</Info>\n   285→\n   286→Both approaches still require the TLS-terminating proxy and trusted CA certificate—they just ensure traffic actually reaches the proxy.\n   287→\n   288→## Filesystem configuration\n   289→\n   290→Filesystem controls determine what files the agent can read and write.\n   291→\n   292→### Read-only code mounting\n   293→\n   294→When the agent needs to analyze code but not modify it, mount the directory read-only:\n   295→\n   296→```bash\n   297→docker run -v /path/to/code:/workspace:ro agent-image\n   298→```\n   299→\n   300→<Warning>\n   301→Even read-only access to a code directory can expose credentials. Common files to exclude or sanitize before mounting:\n   302→\n   303→| File | Risk |\n   304→|------|------|\n   305→| `.env`, `.env.local` | API keys, database passwords, secrets |\n   306→| `~/.git-credentials` | Git passwords/tokens in plaintext |\n   307→| `~/.aws/credentials` | AWS access keys |\n   308→| `~/.config/gcloud/application_default_credentials.json` | Google Cloud ADC tokens |\n   309→| `~/.azure/` | Azure CLI credentials |\n   310→| `~/.docker/config.json` | Docker registry auth tokens |\n   311→| `~/.kube/config` | Kubernetes cluster credentials |\n   312→| `.npmrc`, `.pypirc` | Package registry tokens |\n   313→| `*-service-account.json` | GCP service account keys |\n   314→| `*.pem`, `*.key` | Private keys |\n   315→\n   316→Consider copying only the source files needed, or using `.dockerignore`-style filtering.\n   317→</Warning>\n   318→\n   319→### Writable locations\n   320→\n   321→If the agent needs to write files, you have a few options depending on whether you want changes to persist:\n   322→\n   323→For ephemeral workspaces in containers, use `tmpfs` mounts that exist only in memory and are cleared when the container stops:\n   324→\n   325→```bash\n   326→docker run \\\n   327→  --read-only \\\n   328→  --tmpfs /tmp:rw,noexec,nosuid,size=100m \\\n   329→  --tmpfs /workspace:rw,noexec,size=500m \\\n   330→  agent-image\n   331→```\n   332→\n   333→If you want to review changes before persisting them, an overlay filesystem lets the agent write without modifying underlying files—changes are stored in a separate layer you can inspect, apply, or discard. For fully persistent output, mount a dedicated volume but keep it separate from sensitive directories.\n   334→\n   335→## Further reading\n   336→\n   337→- [Claude Code security documentation](https://code.claude.com/docs/en/security)\n   338→- [Hosting the Agent SDK](/docs/en/agent-sdk/hosting)\n   339→- [Handling permissions](/docs/en/agent-sdk/permissions)\n   340→- [Sandbox runtime](https://github.com/anthropic-experimental/sandbox-runtime)\n   341→- [The Lethal Trifecta for AI Agents](https://simonwillison.net/2025/Jun/16/the-lethal-trifecta/)\n   342→- [OWASP Top 10 for LLM Applications](https://owasp.org/www-project-top-10-for-large-language-model-applications/)\n   343→- [Docker Security Best Practices](https://docs.docker.com/engine/security/)\n   344→- [gVisor Documentation](https://gvisor.dev/docs/)\n   345→- [Firecracker Documentation](https://firecracker-microvm.github.io/)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"c7192068-9943-4eb1-8424-67320f420fa9","uuid":"7a69322c-d264-41c9-9bcc-ab6ff5047423","tool_use_result":{"type":"text","file":{"filePath":"/Users/zaf/projects/cc-insights/docs/anthropic-agent-cli-sdk/secure-deployment.md","content":"# Securely deploying AI agents\n\nA guide to securing Claude Code and Agent SDK deployments with isolation, credential management, and network controls\n\n---\n\nClaude Code and the Agent SDK are powerful tools that can execute code, access files, and interact with external services on your behalf. Like any tool with these capabilities, deploying them thoughtfully ensures you get the benefits while maintaining appropriate controls.\n\nUnlike traditional software that follows predetermined code paths, these tools generate their actions dynamically based on context and goals. This flexibility is what makes them useful, but it also means their behavior can be influenced by the content they process: files, webpages, or user input. This is sometimes called prompt injection. For example, if a repository's README contains unusual instructions, Claude Code might incorporate those into its actions in ways the operator didn't anticipate. This guide covers practical ways to reduce this risk.\n\nThe good news is that securing an agent deployment doesn't require exotic infrastructure. The same principles that apply to running any semi-trusted code apply here: isolation, least privilege, and defense in depth. Claude Code includes several security features that help with common concerns, and this guide walks through these along with additional hardening options for those who need them.\n\nNot every deployment needs maximum security. A developer running Claude Code on their laptop has different requirements than a company processing customer data in a multi-tenant environment. This guide presents options ranging from Claude Code's built-in security features to hardened production architectures, so you can choose what fits your situation.\n\n## What are we protecting against?\n\nAgents can take unintended actions due to prompt injection (instructions embedded in content they process) or model error. Claude models are designed to resist this, and as we analyzed in our [model card](https://assets.anthropic.com/m/64823ba7485345a7/Claude-Opus-4-5-System-Card.pdf), we believe Claude Opus 4.5 is the most robust frontier model available.\n\nDefense in depth is still good practice though. For example, if an agent processes a malicious file that instructs it to send customer data to an external server, network controls can block that request entirely.\n\n## Built-in security features\n\nClaude Code includes several security features that address common concerns. See the [security documentation](https://code.claude.com/docs/en/security) for full details.\n\n- **Permissions system**: Every tool and bash command can be configured to allow, block, or prompt the user for approval. Use glob patterns to create rules like \"allow all npm commands\" or \"block any command with sudo\". Organizations can set policies that apply across all users. See [access control and permissions](https://code.claude.com/docs/en/iam#access-control-and-permissions).\n- **Static analysis**: Before executing bash commands, Claude Code runs static analysis to identify potentially risky operations. Commands that modify system files or access sensitive directories are flagged and require explicit user approval.\n- **Web search summarization**: Search results are summarized rather than passing raw content directly into the context, reducing the risk of prompt injection from malicious web content.\n- **Sandbox mode**: Bash commands can run in a sandboxed environment that restricts filesystem and network access. See the [sandboxing documentation](https://code.claude.com/docs/en/sandboxing) for details.\n\n## Security principles\n\nFor deployments that require additional hardening beyond Claude Code's defaults, these principles guide the available options.\n\n### Security boundaries\n\nA security boundary separates components with different trust levels. For high-security deployments, you can place sensitive resources (like credentials) outside the boundary containing the agent. If something goes wrong in the agent's environment, resources outside that boundary remain protected.\n\nFor example, rather than giving an agent direct access to an API key, you could run a proxy outside the agent's environment that injects the key into requests. The agent can make API calls, but it never sees the credential itself. This pattern is useful for multi-tenant deployments or when processing untrusted content.\n\n### Least privilege\n\nWhen needed, you can restrict the agent to only the capabilities required for its specific task:\n\n| Resource | Restriction options |\n|----------|---------------------|\n| Filesystem | Mount only needed directories, prefer read-only |\n| Network | Restrict to specific endpoints via proxy |\n| Credentials | Inject via proxy rather than exposing directly |\n| System capabilities | Drop Linux capabilities in containers |\n\n### Defense in depth\n\nFor high-security environments, layering multiple controls provides additional protection. Options include:\n\n- Container isolation\n- Network restrictions\n- Filesystem controls\n- Request validation at a proxy\n\nThe right combination depends on your threat model and operational requirements.\n\n## Isolation technologies\n\nDifferent isolation technologies offer different tradeoffs between security strength, performance, and operational complexity.\n\n<Info>\nIn all of these configurations, Claude Code (or your Agent SDK application) runs inside the isolation boundary—the sandbox, container, or VM. The security controls described below restrict what the agent can access from within that boundary.\n</Info>\n\n| Technology | Isolation strength | Performance overhead | Complexity |\n|------------|-------------------|---------------------|------------|\n| Sandbox runtime | Good (secure defaults) | Very low | Low |\n| Containers (Docker) | Setup dependent | Low | Medium |\n| gVisor | Excellent (with correct setup) | Medium/High | Medium |\n| VMs (Firecracker, QEMU) | Excellent (with correct setup) | High | Medium/High |\n\n### Sandbox runtime\n\nFor lightweight isolation without containers, [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime) enforces filesystem and network restrictions at the OS level.\n\nThe main advantage is simplicity: no Docker configuration, container images, or networking setup required. The proxy and filesystem restrictions are built in. You provide a settings file specifying allowed domains and paths.\n\n**How it works:**\n- **Filesystem**: Uses OS primitives (`bubblewrap` on Linux, `sandbox-exec` on macOS) to restrict read/write access to configured paths\n- **Network**: Removes network namespace (Linux) or uses Seatbelt profiles (macOS) to route network traffic through a built-in proxy\n- **Configuration**: JSON-based allowlists for domains and filesystem paths\n\n**Setup:**\n```bash\nnpm install @anthropic-ai/sandbox-runtime\n```\n\nThen create a configuration file specifying allowed paths and domains.\n\n**Security considerations:**\n\n1. **Same-host kernel**: Unlike VMs, sandboxed processes share the host kernel. A kernel vulnerability could theoretically enable escape. For some threat models this is acceptable, but if you need kernel-level isolation, use gVisor or a separate VM.\n\n2. **No TLS inspection**: The proxy allowlists domains but doesn't inspect encrypted traffic. If the agent has permissive credentials for an allowed domain, ensure it isn't possible to use that domain to trigger other network requests or to exfiltrate data.\n\nFor many single-developer and CI/CD use cases, sandbox-runtime raises the bar significantly with minimal setup. The sections below cover containers and VMs for deployments requiring stronger isolation.\n\n### Containers\n\nContainers provide isolation through Linux namespaces. Each container has its own view of the filesystem, process tree, and network stack, while sharing the host kernel.\n\nA security-hardened container configuration might look like this:\n\n```bash\ndocker run \\\n  --cap-drop ALL \\\n  --security-opt no-new-privileges \\\n  --security-opt seccomp=/path/to/seccomp-profile.json \\\n  --read-only \\\n  --tmpfs /tmp:rw,noexec,nosuid,size=100m \\\n  --tmpfs /home/agent:rw,noexec,nosuid,size=500m \\\n  --network none \\\n  --memory 2g \\\n  --cpus 2 \\\n  --pids-limit 100 \\\n  --user 1000:1000 \\\n  -v /path/to/code:/workspace:ro \\\n  -v /var/run/proxy.sock:/var/run/proxy.sock:ro \\\n  agent-image\n```\n\nHere's what each option does:\n\n| Option | Purpose |\n|--------|---------|\n| `--cap-drop ALL` | Removes Linux capabilities like `NET_ADMIN` and `SYS_ADMIN` that could enable privilege escalation |\n| `--security-opt no-new-privileges` | Prevents processes from gaining privileges through setuid binaries |\n| `--security-opt seccomp=...` | Restricts available syscalls; Docker's default blocks ~44, custom profiles can block more |\n| `--read-only` | Makes the container's root filesystem immutable, preventing the agent from persisting changes |\n| `--tmpfs /tmp:...` | Provides a writable temporary directory that's cleared when the container stops |\n| `--network none` | Removes all network interfaces; the agent communicates through the mounted Unix socket below |\n| `--memory 2g` | Limits memory usage to prevent resource exhaustion |\n| `--pids-limit 100` | Limits process count to prevent fork bombs |\n| `--user 1000:1000` | Runs as a non-root user |\n| `-v ...:/workspace:ro` | Mounts code read-only so the agent can analyze but not modify it. **Avoid mounting sensitive host directories like `~/.ssh`, `~/.aws`, or `~/.config`** |\n| `-v .../proxy.sock:...` | Mounts a Unix socket connected to a proxy running outside the container (see below) |\n\n**Unix socket architecture:**\n\nWith `--network none`, the container has no network interfaces at all. The only way for the agent to reach the outside world is through the mounted Unix socket, which connects to a proxy running on the host. This proxy can enforce domain allowlists, inject credentials, and log all traffic.\n\nThis is the same architecture used by [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime). Even if the agent is compromised via prompt injection, it cannot exfiltrate data to arbitrary servers—it can only communicate through the proxy, which controls what domains are reachable. For more details, see the [Claude Code sandboxing blog post](https://www.anthropic.com/engineering/claude-code-sandboxing).\n\n**Additional hardening options:**\n\n| Option | Purpose |\n|--------|---------|\n| `--userns-remap` | Maps container root to unprivileged host user; requires daemon configuration but limits damage from container escape |\n| `--ipc private` | Isolates inter-process communication to prevent cross-container attacks |\n\n### gVisor\n\nStandard containers share the host kernel: when code inside a container makes a system call, it goes directly to the same kernel that runs the host. This means a kernel vulnerability could allow container escape. gVisor addresses this by intercepting system calls in userspace before they reach the host kernel, implementing its own compatibility layer that handles most syscalls without involving the real kernel.\n\nIf an agent runs malicious code (perhaps due to prompt injection), that code runs in the container and could attempt kernel exploits. With gVisor, the attack surface is much smaller: the malicious code would need to exploit gVisor's userspace implementation first and would have limited access to the real kernel.\n\nTo use gVisor with Docker, install the `runsc` runtime and configure the daemon:\n\n```json\n// /etc/docker/daemon.json\n{\n  \"runtimes\": {\n    \"runsc\": {\n      \"path\": \"/usr/local/bin/runsc\"\n    }\n  }\n}\n```\n\nThen run containers with:\n\n```bash\ndocker run --runtime=runsc agent-image\n```\n\n**Performance considerations:**\n\n| Workload | Overhead |\n|----------|----------|\n| CPU-bound computation | ~0% (no syscall interception) |\n| Simple syscalls | ~2× slower |\n| File I/O intensive | Up to 10-200× slower for heavy open/close patterns |\n\nFor multi-tenant environments or when processing untrusted content, the additional isolation is often worth the overhead.\n\n### Virtual machines\n\nVMs provide hardware-level isolation through CPU virtualization extensions. Each VM runs its own kernel, creating a strong boundary—a vulnerability in the guest kernel doesn't directly compromise the host. However, VMs aren't automatically \"more secure\" than alternatives like gVisor. VM security depends heavily on the hypervisor and device emulation code.\n\nFirecracker is designed for lightweight microVM isolation—it can boot VMs in under 125ms with less than 5 MiB memory overhead, stripping away unnecessary device emulation to reduce attack surface.\n\nWith this approach, the agent VM has no external network interface. Instead, it communicates through `vsock` (virtual sockets). All traffic routes through vsock to a proxy on the host, which enforces allowlists and injects credentials before forwarding requests.\n\n### Cloud deployments\n\nFor cloud deployments, you can combine any of the above isolation technologies with cloud-native network controls:\n\n1. Run agent containers in a private subnet with no internet gateway\n2. Configure cloud firewall rules (AWS Security Groups, GCP VPC firewall) to block all egress except to your proxy\n3. Run a proxy (such as [Envoy](https://www.envoyproxy.io/) with its `credential_injector` filter) that validates requests, enforces domain allowlists, injects credentials, and forwards to external APIs\n4. Assign minimal IAM permissions to the agent's service account, routing sensitive access through the proxy where possible\n5. Log all traffic at the proxy for audit purposes\n\n## Credential management\n\nAgents often need credentials to call APIs, access repositories, or interact with cloud services. The challenge is providing this access without exposing the credentials themselves.\n\n### The proxy pattern\n\nThe recommended approach is to run a proxy outside the agent's security boundary that injects credentials into outgoing requests. The agent sends requests without credentials, the proxy adds them, and forwards the request to its destination.\n\nThis pattern has several benefits:\n\n1. The agent never sees the actual credentials\n2. The proxy can enforce an allowlist of permitted endpoints\n3. The proxy can log all requests for auditing\n4. Credentials are stored in one secure location rather than distributed to each agent\n\n### Configuring Claude Code to use a proxy\n\nClaude Code supports two methods for routing sampling requests through a proxy:\n\n**Option 1: ANTHROPIC_BASE_URL (simple but only for sampling API requests)**\n\n```bash\nexport ANTHROPIC_BASE_URL=\"http://localhost:8080\"\n```\n\nThis tells Claude Code and the Agent SDK to send sampling requests to your proxy instead of the Anthropic API directly. Your proxy receives plaintext HTTP requests, can inspect and modify them (including injecting credentials), then forwards to the real API.\n\n**Option 2: HTTP_PROXY / HTTPS_PROXY (system-wide)**\n\n```bash\nexport HTTP_PROXY=\"http://localhost:8080\"\nexport HTTPS_PROXY=\"http://localhost:8080\"\n```\n\nClaude Code and the Agent SDK respect these standard environment variables, routing all HTTP traffic through the proxy. For HTTPS, the proxy creates an encrypted CONNECT tunnel: it cannot see or modify request contents without TLS interception.\n\n### Implementing a proxy\n\nYou can build your own proxy or use an existing one:\n\n- [Envoy Proxy](https://www.envoyproxy.io/) — production-grade proxy with `credential_injector` filter for adding auth headers\n- [mitmproxy](https://mitmproxy.org/) — TLS-terminating proxy for inspecting and modifying HTTPS traffic\n- [Squid](http://www.squid-cache.org/) — caching proxy with access control lists\n- [LiteLLM](https://github.com/BerriAI/litellm) — LLM gateway with credential injection and rate limiting\n\n### Credentials for other services\n\nBeyond sampling from the Anthropic API, agents often need authenticated access to other services—git repositories, databases, internal APIs. There are two main approaches:\n\n#### Custom tools\n\nProvide access through an MCP server or custom tool that routes requests to a service running outside the agent's security boundary. The agent calls the tool, but the actual authenticated request happens outside—the tool calls to a proxy which injects the credentials.\n\nFor example, a git MCP server could accept commands from the agent but forward them to a git proxy running on the host, which adds authentication before contacting the remote repository. The agent never sees the credentials.\n\nAdvantages:\n- **No TLS interception**: The external service makes authenticated requests directly\n- **Credentials stay outside**: The agent only sees the tool interface, not the underlying credentials\n\n#### Traffic forwarding\n\nFor Anthropic API calls, `ANTHROPIC_BASE_URL` lets you route requests to a proxy that can inspect and modify them in plaintext. But for other HTTPS services (GitHub, npm registries, internal APIs), the traffic is often encrypted end-to-end—even if you route it through a proxy via `HTTP_PROXY`, the proxy only sees an opaque TLS tunnel and can't inject credentials.\n\nTo modify HTTPS traffic to arbitrary services, without using a custom tool, you need a TLS-terminating proxy that decrypts traffic, inspects or modifies it, then re-encrypts it before forwarding. This requires:\n\n1. Running the proxy outside the agent's container\n2. Installing the proxy's CA certificate in the agent's trust store (so the agent trusts the proxy's certificates)\n3. Configuring `HTTP_PROXY`/`HTTPS_PROXY` to route traffic through the proxy\n\nThis approach handles any HTTP-based service without writing custom tools, but adds complexity around certificate management.\n\nNote that not all programs respect `HTTP_PROXY`/`HTTPS_PROXY`. Most tools (curl, pip, npm, git) do, but some may bypass these variables and connect directly. For example, Node.js `fetch()` ignores these variables by default; in Node 24+ you can set `NODE_USE_ENV_PROXY=1` to enable support. For comprehensive coverage, you can use [proxychains](https://github.com/haad/proxychains) to intercept network calls, or configure iptables to redirect outbound traffic to a transparent proxy.\n\n<Info>\nA **transparent proxy** intercepts traffic at the network level, so the client doesn't need to be configured to use it. Regular proxies require clients to explicitly connect and speak HTTP CONNECT or SOCKS. Transparent proxies (like Squid or mitmproxy in transparent mode) can handle raw redirected TCP connections.\n</Info>\n\nBoth approaches still require the TLS-terminating proxy and trusted CA certificate—they just ensure traffic actually reaches the proxy.\n\n## Filesystem configuration\n\nFilesystem controls determine what files the agent can read and write.\n\n### Read-only code mounting\n\nWhen the agent needs to analyze code but not modify it, mount the directory read-only:\n\n```bash\ndocker run -v /path/to/code:/workspace:ro agent-image\n```\n\n<Warning>\nEven read-only access to a code directory can expose credentials. Common files to exclude or sanitize before mounting:\n\n| File | Risk |\n|------|------|\n| `.env`, `.env.local` | API keys, database passwords, secrets |\n| `~/.git-credentials` | Git passwords/tokens in plaintext |\n| `~/.aws/credentials` | AWS access keys |\n| `~/.config/gcloud/application_default_credentials.json` | Google Cloud ADC tokens |\n| `~/.azure/` | Azure CLI credentials |\n| `~/.docker/config.json` | Docker registry auth tokens |\n| `~/.kube/config` | Kubernetes cluster credentials |\n| `.npmrc`, `.pypirc` | Package registry tokens |\n| `*-service-account.json` | GCP service account keys |\n| `*.pem`, `*.key` | Private keys |\n\nConsider copying only the source files needed, or using `.dockerignore`-style filtering.\n</Warning>\n\n### Writable locations\n\nIf the agent needs to write files, you have a few options depending on whether you want changes to persist:\n\nFor ephemeral workspaces in containers, use `tmpfs` mounts that exist only in memory and are cleared when the container stops:\n\n```bash\ndocker run \\\n  --read-only \\\n  --tmpfs /tmp:rw,noexec,nosuid,size=100m \\\n  --tmpfs /workspace:rw,noexec,size=500m \\\n  agent-image\n```\n\nIf you want to review changes before persisting them, an overlay filesystem lets the agent write without modifying underlying files—changes are stored in a separate layer you can inspect, apply, or discard. For fully persistent output, mount a dedicated volume but keep it separate from sensitive directories.\n\n## Further reading\n\n- [Claude Code security documentation](https://code.claude.com/docs/en/security)\n- [Hosting the Agent SDK](/docs/en/agent-sdk/hosting)\n- [Handling permissions](/docs/en/agent-sdk/permissions)\n- [Sandbox runtime](https://github.com/anthropic-experimental/sandbox-runtime)\n- [The Lethal Trifecta for AI Agents](https://simonwillison.net/2025/Jun/16/the-lethal-trifecta/)\n- [OWASP Top 10 for LLM Applications](https://owasp.org/www-project-top-10-for-large-language-model-applications/)\n- [Docker Security Best Practices](https://docs.docker.com/engine/security/)\n- [gVisor Documentation](https://gvisor.dev/docs/)\n- [Firecracker Documentation](https://firecracker-microvm.github.io/)","numLines":345,"startLine":1,"totalLines":345}}}}
{"timestamp":"2026-02-09T20:35:44.962420","level":"debug","direction":"stdout","content":{"type":"system","subtype":"status","status":"compacting","session_id":"c7192068-9943-4eb1-8424-67320f420fa9","uuid":"2a86e32f-3a7a-4315-b12d-cf39861a3346"}}
{"timestamp":"2026-02-09T20:35:44.962724","level":"debug","direction":"stdout","content":{"type":"system","subtype":"status","status":null,"session_id":"c7192068-9943-4eb1-8424-67320f420fa9","uuid":"87f52fc1-89ac-4385-ac13-17cb4dff6056"}}
{"timestamp":"2026-02-09T20:35:44.962877","level":"debug","direction":"stdout","content":{"type":"assistant","message":{"id":"4b44497b-0523-455a-b496-1762163fd629","container":null,"model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":null,"cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"content":[{"type":"text","text":"Prompt is too long"}],"context_management":null},"parent_tool_use_id":null,"session_id":"c7192068-9943-4eb1-8424-67320f420fa9","uuid":"dc812a0e-dc53-4255-af6d-8d2b6addde44","error":"invalid_request"}}
{"timestamp":"2026-02-09T20:35:44.963001","level":"debug","direction":"stdout","content":{"type":"result","subtype":"success","is_error":true,"duration_ms":11319,"duration_api_ms":48333,"num_turns":10,"result":"Prompt is too long","stop_reason":"stop_sequence","session_id":"c7192068-9943-4eb1-8424-67320f420fa9","total_cost_usd":1.05942275,"usage":{"input_tokens":4,"cache_creation_input_tokens":1299,"cache_read_input_tokens":288832,"output_tokens":578,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1299,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-6":{"inputTokens":12,"outputTokens":2397,"cacheReadInputTokens":385288,"cacheCreationInputTokens":129087,"webSearchRequests":0,"costUSD":1.05942275,"contextWindow":200000,"maxOutputTokens":32000}},"permission_denials":[],"uuid":"efddd042-2908-406c-9f4a-59c7bf8dd23a"}}
{"timestamp":"2026-02-09T20:35:55.538080","level":"debug","direction":"stdin","content":{"type":"user","message":{"role":"user","content":"can you hear me?"}}}
{"timestamp":"2026-02-09T20:35:55.604308","level":"debug","direction":"stdout","content":{"type":"system","subtype":"init","cwd":"/Users/zaf/projects/cc-insights","session_id":"c7192068-9943-4eb1-8424-67320f420fa9","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch","mcp__flutter-test__run_tests","mcp__flutter-test__get_test_result"],"mcp_servers":[{"name":"flutter-test","status":"connected"}],"model":"claude-opus-4-6","permissionMode":"acceptEdits","slash_commands":["keybindings-help","debug","compact","context","cost","init","pr-comments","release-notes","review","security-review","insights"],"apiKeySource":"none","claude_code_version":"2.1.37","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","flutter-engineer","flutter-senior-dev"],"skills":["keybindings-help","debug"],"plugins":[],"uuid":"19ce425e-e1a7-4f48-8a12-b6ab57952065"}}
{"timestamp":"2026-02-09T20:35:56.345338","level":"debug","direction":"stdout","content":{"type":"assistant","message":{"id":"40597937-8396-4859-8636-62433b5a27c9","container":null,"model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":null,"cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"content":[{"type":"text","text":"Prompt is too long"}],"context_management":null},"parent_tool_use_id":null,"session_id":"c7192068-9943-4eb1-8424-67320f420fa9","uuid":"5c90c5e8-ecd1-4c16-832c-6e93a7df4f83","error":"invalid_request"}}
{"timestamp":"2026-02-09T20:35:56.347481","level":"debug","direction":"stdout","content":{"type":"result","subtype":"success","is_error":true,"duration_ms":806,"duration_api_ms":48333,"num_turns":1,"result":"Prompt is too long","stop_reason":"stop_sequence","session_id":"c7192068-9943-4eb1-8424-67320f420fa9","total_cost_usd":1.05942275,"usage":{"input_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":0,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"modelUsage":{"claude-opus-4-6":{"inputTokens":12,"outputTokens":2397,"cacheReadInputTokens":385288,"cacheCreationInputTokens":129087,"webSearchRequests":0,"costUSD":1.05942275,"contextWindow":200000,"maxOutputTokens":32000}},"permission_denials":[],"uuid":"48d1dac1-5f66-42db-b4c2-1c110b53e113"}}
{"timestamp":"2026-02-09T20:36:52.018455","level":"info","direction":"internal","sessionId":"4bccec3a-f6f3-413b-ba20-4a9110262d39","message":"Session disposed"}
